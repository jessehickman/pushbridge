import{s as l,r as u,P as h,g as d,h as k,a as D,n as _,u as y,f as qe,b as Re,c as re,d as v,e as se,i as Ve,j as R,t as V,k as Ke,l as Ye,m as ie,o as Qe,p as Je,q as Xe,v as Ze,w as et,x as tt}from"./notificationBadge.js";const ot="modulepreload",at=function(e){return"/"+e},K={},E=function(t,o,a){let n=Promise.resolve();if(o&&o.length>0){let i=function(w){return Promise.all(w.map(g=>Promise.resolve(g).then(m=>({status:"fulfilled",value:m}),m=>({status:"rejected",reason:m}))))};document.getElementsByTagName("link");const s=document.querySelector("meta[property=csp-nonce]"),c=s?.nonce||s?.getAttribute("nonce");n=i(o.map(w=>{if(w=at(w),w in K)return;K[w]=!0;const g=w.endsWith(".css"),m=g?'[rel="stylesheet"]':"";if(document.querySelector(`link[href="${w}"]${m}`))return;const f=document.createElement("link");if(f.rel=g?"stylesheet":ot,g||(f.as="script"),f.crossOrigin="",f.href=w,c&&f.setAttribute("nonce",c),document.head.appendChild(f),g)return new Promise((C,ze)=>{f.addEventListener("load",C),f.addEventListener("error",()=>ze(new Error(`Unable to preload CSS for ${w}`)))})}))}function r(s){const c=new Event("vite:preloadError",{cancelable:!0});if(c.payload=s,window.dispatchEvent(c),!c.defaultPrevented)throw s}return n.then(s=>{for(const c of s||[])c.status==="rejected"&&r(c.reason);return t().catch(r)})};let P=null,M=null,$=0,A=0;const nt=6,ce=nt*60*60*1e3;async function G(e=!1){try{const t=await d("pb_token");if(!t)throw new Error("No access token available");let o;e||(o=await d("pb_subscriptions_cursor"));const a=new URLSearchParams;o&&a.append("cursor",o);const n=o?`https://api.pushbullet.com/v2/subscriptions?${a}`:"https://api.pushbullet.com/v2/subscriptions",r=await k.fetch(n,{method:"GET",headers:{"Access-Token":t,"Content-Type":"application/json"}});if(!r.ok)throw r.status===401?(await u(h.TokenRevoked,{message:"Token revoked during channel fetch",code:r.status}),new Error("Token is invalid or revoked")):new Error(`Failed to fetch subscriptions: ${r.status} ${r.statusText}`);const s=await r.json();return s.cursor?(await l("pb_subscriptions_cursor",s.cursor),await l("pb_subscriptions_has_more",!0)):(await l("pb_subscriptions_cursor",null),await l("pb_subscriptions_has_more",!1)),await rt(s.subscriptions),chrome.runtime.sendMessage({type:"pb:subsUpdated",payload:{subscriptions:s.subscriptions}}).catch(()=>{}),s.subscriptions}catch(t){throw console.error("Failed to fetch channel subscriptions:",t),await u(h.Unknown,{message:`Failed to fetch channel subscriptions: ${t instanceof Error?t.message:"Unknown error"}`}),t}}async function le(e=!1){try{const t=await d("pb_token");if(!t)throw new Error("No access token available");let o;e||(o=await d("pb_channels_cursor"));const a=new URLSearchParams;a.append("active_only","true"),o&&a.append("cursor",o);const n=o?`https://api.pushbullet.com/v2/channels?${a}`:"https://api.pushbullet.com/v2/channels?active_only=true",r=await k.fetch(n,{method:"GET",headers:{"Access-Token":t,"Content-Type":"application/json"}});if(!r.ok)throw r.status===401?(await u(h.TokenRevoked,{message:"Token revoked during owned channels fetch",code:r.status}),new Error("Token is invalid or revoked")):new Error(`Failed to fetch owned channels: ${r.status} ${r.statusText}`);const s=await r.json();return s.cursor?(await l("pb_channels_cursor",s.cursor),await l("pb_channels_has_more",!0)):(await l("pb_channels_cursor",null),await l("pb_channels_has_more",!1)),await st(s.channels),chrome.runtime.sendMessage({type:"pb:ownedChannelsUpdated",payload:{channels:s.channels}}).catch(()=>{}),s.channels}catch(t){throw console.error("Failed to fetch owned channels:",t),await u(h.Unknown,{message:`Failed to fetch owned channels: ${t instanceof Error?t.message:"Unknown error"}`}),t}}async function de(e=!1){const t=Date.now();return!e&&P&&t-$<ce?P:await G(e)}async function ue(e=!1){const t=Date.now();return!e&&M&&t-A<ce?M:await le(e)}async function rt(e){P=e,$=Date.now(),await l("pb_channel_subs",{subscriptions:e,lastFetched:$})}async function st(e){M=e,A=Date.now(),await l("pb_owned_channels",{channels:e,lastFetched:A})}async function j(){try{console.log("Refreshing channel data (subscriptions and owned channels)..."),await Promise.all([G(),le()]),console.log("Channel data refresh completed")}catch(e){throw console.error("Failed to refresh channel data:",e),await u(h.Unknown,{message:`Failed to refresh channel data: ${e instanceof Error?e.message:"Unknown error"}`}),e}}async function he(){try{const e=await d("pb_channel_subs");if(e&&e.subscriptions)return P=e.subscriptions,$=e.lastFetched,e.subscriptions}catch(e){console.error("Failed to load cached subscriptions:",e)}return[]}async function fe(){try{const e=await d("pb_owned_channels");if(e&&e.channels)return M=e.channels,A=e.lastFetched,e.channels}catch(e){console.error("Failed to load cached owned channels:",e)}return[]}async function pe(){P=null,$=0,await l("pb_channel_subs",null),await l("pb_subscriptions_cursor",null),await l("pb_subscriptions_has_more",null)}async function ge(){M=null,A=0,await l("pb_owned_channels",null),await l("pb_channels_cursor",null),await l("pb_channels_has_more",null)}async function we(){try{await Promise.all([he(),fe()]),console.log("Channel manager initialized")}catch(e){console.error("Failed to initialize channel manager:",e)}}async function me(e=50){try{const{getPushHistory:t}=await E(async()=>{const{getPushHistory:r}=await Promise.resolve().then(()=>_t);return{getPushHistory:r}},void 0),[o,a]=await Promise.all([t(e*2),de()]),n=new Set(a.filter(r=>r.channel&&r.channel.iden).map(r=>r.channel.iden));return o.pushes.filter(r=>r.channel_iden&&n.has(r.channel_iden)).sort((r,s)=>s.created-r.created).slice(0,e)}catch(t){throw console.error("Failed to get subscription posts:",t),await u(h.Unknown,{message:`Failed to get subscription posts: ${t instanceof Error?t.message:"Unknown error"}`}),t}}const I=Object.freeze(Object.defineProperty({__proto__:null,clearOwnedChannelsCache:ge,clearSubscriptionsCache:pe,fetchSubscriptions:G,getOwnedChannels:ue,getSubscriptionPosts:me,getSubscriptions:de,initializeChannelManager:we,loadCachedOwnedChannels:fe,loadCachedSubscriptions:he,refreshChannelData:j},Symbol.toStringTag,{value:"Module"})),it=1440*60*1e3,b="mirror_";async function ct(e){try{if(console.log("üîî [MirrorManager] Handling mirror push:",{application_name:e.application_name,package_name:e.package_name,title:e.title}),e.application_name==="SMS"){await ft(e);return}const t=`${Date.now()}_${Math.random().toString(36).substr(2,9)}`,o={package_name:e.package_name,notification_id:e.notification_id,notification_tag:e.notification_tag,source_device_iden:e.source_device_iden,title:e.title,body:e.body,application_name:e.application_name,icon_url:e.icon_url,expiresAt:Date.now()+it};await l(`${b}${t}`,o);const a={type:"basic",title:e.title,message:e.body,iconUrl:e.icon_url?e.icon_url:"icons/48.png",requireInteraction:!0,silent:!1};await chrome.notifications.create(t,a),console.log("üîî [MirrorManager] Adding mirror notification to badge"),await _.addPushNotifications(1),await y.markAsProcessed("mirror",e.notification_id,Date.now()),console.log("Chrome notification created:",t,"for app:",e.package_name)}catch(t){console.error("Failed to handle mirror push:",t),await u(h.Unknown,{message:"Failed to create notification from phone",code:t instanceof Error?void 0:500})}}async function lt(e){try{console.log("üóëÔ∏è [MirrorManager] Handling remote dismissal:",{package_name:e.package_name,notification_id:e.notification_id});const t=await dt(e);for(const[o]of t)await chrome.notifications.clear(o),await D(`${b}${o}`),console.log("üóëÔ∏è [MirrorManager] Removing mirror notification from badge"),await _.addPushNotifications(-1),console.log("Chrome notification cleared:",o,"for app:",e.package_name)}catch(t){console.error("Failed to handle remote dismissal:",t),await u(h.Unknown,{message:"Failed to clear notification from phone",code:t instanceof Error?void 0:500})}}async function ke(e){try{console.log("üë§ [MirrorManager] Handling user dismissal for:",e);const t=await d(`${b}${e}`);if(!t){console.log("No metadata found for notification:",e),await chrome.notifications.clear(e);return}const o=await d("pb_user_iden");if(!o){console.error("No user ID found for dismissal");return}await ut(t,o),await D(`${b}${e}`),console.log("üë§ [MirrorManager] Removing mirror notification from badge (user dismissal)"),await _.addPushNotifications(-1),console.log("User dismissal sent to phone for:",e)}catch(t){console.error("Failed to handle user dismissal:",t),await u(h.Unknown,{message:"Failed to dismiss notification on phone",code:t instanceof Error?void 0:500})}}async function dt(e){const t=[];try{const o=await chrome.storage.local.get(null);for(const[a,n]of Object.entries(o))if(a.startsWith(b)){const r=n;if(r.package_name===e.package_name&&r.notification_id===e.notification_id&&r.notification_tag===e.notification_tag){const s=a.replace(b,"");t.push([s,r])}}}catch(o){console.error("Failed to find matching mirrors:",o)}return t}async function ut(e,t){try{const o=await d("pb_token");if(!o)throw new Error("No token available");const a={type:"push",push:{type:"dismissal",package_name:e.package_name,notification_id:e.notification_id,notification_tag:e.notification_tag,source_user_iden:t}},n=await k.fetch("https://api.pushbullet.com/v2/ephemerals",{method:"POST",headers:{"Content-Type":"application/json","Access-Token":o},body:JSON.stringify(a)});if(!n.ok)throw new Error(`Dismissal API error: ${n.status} ${n.statusText}`);console.log("Dismissal ephemeral sent successfully")}catch(o){throw console.error("Failed to send dismissal ephemeral:",o),o}}async function _e(){try{const e=await chrome.storage.local.get(null),t=Date.now();for(const[o,a]of Object.entries(e))if(o.startsWith(b)){const n=a;if(n.expiresAt<t){await D(o);continue}const r=o.replace(b,""),s={type:"basic",title:n.title,message:n.body,iconUrl:n.icon_url?n.icon_url:"icons/48.png",requireInteraction:!0,silent:!1};await chrome.notifications.create(r,s),console.log("Reconstructed notification:",r)}}catch(e){console.error("Failed to reconstruct mirrors:",e)}}async function ye(){try{console.log("üßπ [MirrorManager] Cleaning up expired mirrors");const e=await chrome.storage.local.get(null),t=Date.now();let o=0;for(const[a,n]of Object.entries(e))a.startsWith(b)&&n.expiresAt<t&&(await D(a),o++,console.log("Cleaned up expired mirror:",a));o>0&&(console.log(`üßπ [MirrorManager] Removed ${o} expired mirrors from badge`),await _.addPushNotifications(-o))}catch(e){console.error("Failed to cleanup expired mirrors:",e)}}async function ht(){const e=[];try{const t=await chrome.storage.local.get(null),o=Date.now();for(const[a,n]of Object.entries(t))if(a.startsWith(b)){const r=n;if(r.expiresAt<o)continue;const s=a.replace(b,"");e.push({id:s,meta:r})}}catch(t){console.error("Failed to get active mirrors:",t)}return e}async function ft(e){try{if(e.application_name!=="SMS")return;const t=e.conversation_iden||`${e.package_name}:${e.address}`||e.notification_id,o=e.timestamp,a=o?qe(o):Date.now();if(console.log("üì± [MirrorManager] Processing SMS with timestamp conversion:",{rawTimestamp:o,rawTimestampISO:o?new Date(o*1e3).toISOString():"none",convertedTimestamp:a,convertedTimestampISO:new Date(a).toISOString(),conversationId:t}),!await y.shouldShowNotification({id:e.notification_id||`sms_${Date.now()}`,type:"sms",created:a,metadata:{conversationId:t,packageName:e.package_name,applicationName:e.application_name}})){console.log(`‚è≠Ô∏è [MirrorManager] Skipping SMS notification (too old): ${t}`);return}const r=`sms_${Date.now()}_${Math.random().toString(36).substr(2,9)}`;console.log("üì± [MirrorManager] Creating Chrome notification for SMS:",{title:e.title,body:e.body,chromeNotifId:r}),await chrome.notifications.create(r,{type:"basic",title:e.title,message:e.body,iconUrl:e.icon_url?e.icon_url:"icons/48.png",requireInteraction:!1,silent:!1});const s={id:e.notification_id||`incoming_${Date.now()}`,pb_guid:e.pb_guid||`incoming_${Date.now()}_${Math.random()}`,timestamp:a,inbound:!0,text:e.body||"",image_url:e.image_url,conversation_iden:t};await Re(t,s,t),await y.markAsProcessed("sms",s.id,a),console.log("‚úÖ [MirrorManager] Incoming SMS processed:",t,"Chrome notif:",r)}catch(t){console.error("Failed to handle incoming SMS:",t),await u(h.Unknown,{message:"Failed to handle incoming SMS",code:t instanceof Error?void 0:500})}}const pt=300*1e3;async function U(e=!1){try{if(!e){const a=await d("pb_contact_cache");if(a&&Date.now()-a.lastFetched<pt)return console.log("Using cached contact list"),a.contacts}const t=await gt(e),o={contacts:t,lastFetched:Date.now(),cursor:await d("pb_contacts_cursor"),hasMore:await d("pb_contacts_has_more")||!1};return await l("pb_contact_cache",o),console.log("Contact list cached with",t.length,"contacts"),t}catch(t){console.error("Failed to get contacts:",t);const o=await d("pb_contact_cache");if(o)return console.log("Returning expired cache due to fetch error"),o.contacts;throw t}}async function gt(e=!1){const t=await d("pb_token");if(!t)throw new Error("No token available");let o;e||(o=await d("pb_contacts_cursor"));const a=new URLSearchParams;o&&a.append("cursor",o);const n=o?`https://api.pushbullet.com/v2/chats?${a}`:"https://api.pushbullet.com/v2/chats",r=await k.fetch(n,{method:"GET",headers:{"Access-Token":t,"Content-Type":"application/json"}});if(!r.ok)throw r.status===401?(await u(h.TokenRevoked,{message:"Token revoked while fetching contacts",code:r.status}),new Error("Token is invalid or revoked")):new Error(`Failed to fetch contacts: ${r.status} ${r.statusText}`);const s=await r.json();s.cursor?(await l("pb_contacts_cursor",s.cursor),await l("pb_contacts_has_more",!0)):(await l("pb_contacts_cursor",null),await l("pb_contacts_has_more",!1));const c=[];if(s.chats&&Array.isArray(s.chats)){for(const i of s.chats)if(i.active&&i.with&&i.with.type==="user"){const w={iden:i.with.iden,name:i.with.name,email:i.with.email,email_normalized:i.with.email_normalized,image_url:i.with.image_url,active:i.active,created:i.created,modified:i.modified};c.push(w)}}return console.log(`Fetched ${c.length} contacts from API`),c}async function be(){try{await l("pb_contact_cache",null),await l("pb_contacts_cursor",null),await l("pb_contacts_has_more",null),console.log("Contact cache cleared")}catch(e){throw console.error("Failed to clear contact cache:",e),e}}async function wt(e){return(await U()).find(o=>o.iden===e)||null}const B="user_context",N="context_refresh_triggers";class T{constructor(){this.context=null,this.isRefreshing=!1,this.refreshPromise=null}static getInstance(){return T.instance||(T.instance=new T),T.instance}async getContext(t){if(t.type==="popup_open"?await this.refreshContext(t):(!this.context||!this.context.is_valid)&&await this.refreshContext(t),!this.context)throw new Error("Failed to load user context");return this.context}async isKnownSource(t,o){if(!this.context)return!1;if(t&&this.context.devices.has(t))return!0;if(o){for(const a of this.context.subscriptions.values())if(a.channel.iden===o)return!0}return!!(o&&this.context.owned_channels.has(o))}async handleUnknownSource(t,o){const a={type:"unknown_source",timestamp:Date.now(),reason:`Unknown source: device=${t}, channel=${o}`};await this.refreshContext(a)}async refreshContext(t){if(this.isRefreshing&&this.refreshPromise){await this.refreshPromise;return}this.isRefreshing=!0,this.refreshPromise=this.performRefresh(t);try{await this.refreshPromise}finally{this.isRefreshing=!1,this.refreshPromise=null}}async performRefresh(t){try{const o=await d("pb_token");if(!o)throw new Error("No token available");const a=await d("pb_device_iden");if(!a)throw new Error("Current device not registered");const[n,r,s,c]=await Promise.all([this.fetchSubscriptions(o),this.fetchChannels(o),this.fetchDevices(o),this.fetchContacts(o)]),i=new Map,w=new Map,g=new Map,m=new Map;r.channels&&Array.isArray(r.channels)&&r.channels.forEach(f=>{f&&f.iden?i.set(f.iden,f):console.warn("Skipping channel with missing iden:",f)}),n.subscriptions&&Array.isArray(n.subscriptions)&&n.subscriptions.forEach(f=>{f.channel&&f.channel.iden?w.set(f.channel.iden,f):console.warn("Skipping subscription with missing channel data:",f)}),s.devices&&Array.isArray(s.devices)&&s.devices.forEach(f=>{f&&f.iden?g.set(f.iden,f):console.warn("Skipping device with missing iden:",f)}),c&&Array.isArray(c)&&c.forEach(f=>{f&&f.iden?m.set(f.iden,f):console.warn("Skipping contact with missing iden:",f)}),this.context={current_device_iden:a,owned_channels:i,subscriptions:w,devices:g,contacts:m,last_refreshed:Date.now(),is_valid:!0},await this.saveContext(),await this.saveRefreshTrigger(t),console.log("Context refreshed successfully",{ownedChannels:i.size,subscriptions:w.size,devices:g.size,contacts:m.size,trigger:t.type})}catch(o){throw console.error("Failed to refresh context:",o),this.context&&(this.context.is_valid=!1,await this.saveContext()),await u(h.Unknown,{message:"Failed to refresh user context",code:o instanceof Error?void 0:500}),o}}async fetchSubscriptions(t){const o=await k.fetch("https://api.pushbullet.com/v2/subscriptions",{method:"GET",headers:{"Access-Token":t,"Content-Type":"application/json"}});if(!o.ok)throw o.status===401?(await u(h.TokenRevoked,{message:"Token revoked while fetching subscriptions",code:o.status}),new Error("Token is invalid or revoked")):new Error(`Failed to fetch subscriptions: ${o.status} ${o.statusText}`);const a=await o.json();if(!a||typeof a!="object")throw new Error("Invalid response format from subscriptions API");return(!a.subscriptions||!Array.isArray(a.subscriptions))&&(console.warn("Subscriptions API returned unexpected format, using empty array"),a.subscriptions=[]),a}async fetchChannels(t){const o=await k.fetch("https://api.pushbullet.com/v2/channels?limit=500&active_only=true",{method:"GET",headers:{"Access-Token":t,"Content-Type":"application/json"}});if(!o.ok)throw o.status===401?(await u(h.TokenRevoked,{message:"Token revoked while fetching channels",code:o.status}),new Error("Token is invalid or revoked")):new Error(`Failed to fetch channels: ${o.status} ${o.statusText}`);const a=await o.json();if(!a||typeof a!="object")throw new Error("Invalid response format from channels API");return(!a.channels||!Array.isArray(a.channels))&&(console.warn("Channels API returned unexpected format, using empty array"),a.channels=[]),a}async fetchDevices(t){const o=await k.fetch("https://api.pushbullet.com/v2/devices",{method:"GET",headers:{"Access-Token":t,"Content-Type":"application/json"}});if(!o.ok)throw o.status===401?(await u(h.TokenRevoked,{message:"Token revoked while fetching devices",code:o.status}),new Error("Token is invalid or revoked")):new Error(`Failed to fetch devices: ${o.status} ${o.statusText}`);const a=await o.json();if(!a||typeof a!="object")throw new Error("Invalid response format from devices API");return(!a.devices||!Array.isArray(a.devices))&&(console.warn("Devices API returned unexpected format, using empty array"),a.devices=[]),a}async fetchContacts(t){const o=await k.fetch("https://api.pushbullet.com/v2/chats",{method:"GET",headers:{"Access-Token":t,"Content-Type":"application/json"}});if(!o.ok)throw o.status===401?(await u(h.TokenRevoked,{message:"Token revoked while fetching contacts",code:o.status}),new Error("Token is invalid or revoked")):new Error(`Failed to fetch contacts: ${o.status} ${o.statusText}`);const a=await o.json(),n=[];if(a.chats&&Array.isArray(a.chats)){for(const r of a.chats)if(r.active&&r.with&&r.with.type==="user"){const s={iden:r.with.iden,name:r.with.name,email:r.with.email,email_normalized:r.with.email_normalized,image_url:r.with.image_url,active:r.active,created:r.created,modified:r.modified};n.push(s)}}return n}async saveContext(){if(this.context){const t={...this.context,owned_channels:Array.from(this.context.owned_channels.entries()),subscriptions:Array.from(this.context.subscriptions.entries()),devices:Array.from(this.context.devices.entries())};await l(B,t)}}async loadContext(){try{const t=await d(B);t&&(this.context={...t,owned_channels:new Map(t.owned_channels||[]),subscriptions:new Map(t.subscriptions||[]),devices:new Map(t.devices||[])})}catch(t){console.error("Failed to load context from storage:",t),this.context=null}}async saveRefreshTrigger(t){try{const o=await d(N),a=Array.isArray(o)?o:[];a.push(t),a.length>10&&a.splice(0,a.length-10),await l(N,a)}catch(o){console.error("Failed to save refresh trigger:",o)}}async getRefreshTriggers(){return await d(N)||[]}async clearContext(){this.context=null,await l(B,null),await l(N,null)}async removeChannelFromContext(t){!this.context||!this.context.subscriptions||(this.context.subscriptions.delete(t),await this.saveContext(),console.log(`Removed channel ${t} from user context`))}}const F=T.getInstance(),mt=Object.freeze(Object.defineProperty({__proto__:null,ContextManager:T,contextManager:F},Symbol.toStringTag,{value:"Module"}));class kt{static enrichPush(t,o){const a=this.computeMetadata(t,o);return{...t,metadata:a}}static enrichPushes(t,o){return t.map(a=>this.enrichPush(a,o))}static computeMetadata(t,o){const a=this.determineSourceType(t,o),n=this.determineOwnership(t,o),r=this.determineFileInfo(t),s=this.computeDisplaySource(t,o,a),c=this.computeOwnershipReason(t,o,n,a);return{source_type:a,source_channel_tag:this.getChannelTag(t,o),source_channel_name:this.getChannelName(t,o),source_device_nickname:this.getDeviceNickname(t,o),is_owned_by_user:n,can_delete:n,can_dismiss:!0,has_file:r,file_metadata:r?this.getFileMetadata(t):void 0,display_source:s,ownership_reason:c}}static determineSourceType(t,o){return t.channel_iden?o.owned_channels.has(t.channel_iden)?"channel_broadcast":(o.subscriptions.has(t.channel_iden),"channel_subscription"):"device"}static determineOwnership(t,o){return!!(t.source_device_iden===o.current_device_iden||t.channel_iden&&o.owned_channels.has(t.channel_iden))}static determineFileInfo(t){return!!(t.file_name||t.file_url||t.image_url)}static getFileMetadata(t){if(this.determineFileInfo(t))return{name:t.file_name||"Unknown file",type:t.file_type||"unknown",url:t.file_url||t.image_url}}static getChannelTag(t,o){if(!t.channel_iden)return;const a=o.owned_channels.get(t.channel_iden);if(a)return a.tag;const n=o.subscriptions.get(t.channel_iden);if(n)return n.channel.tag}static getChannelName(t,o){if(!t.channel_iden)return;const a=o.owned_channels.get(t.channel_iden);if(a)return a.name;const n=o.subscriptions.get(t.channel_iden);if(n)return n.channel.name}static getDeviceNickname(t,o){return t.source_device_iden?o.devices.get(t.source_device_iden)?.nickname:void 0}static computeDisplaySource(t,o,a){switch(a){case"device":{const n=this.getDeviceNickname(t,o);return t.source_device_iden===o.current_device_iden?"Your device":n||"Unknown device"}case"channel_broadcast":return`Channel: ${this.getChannelName(t,o)||"Unknown channel"}`;case"channel_subscription":return`Channel: ${this.getChannelName(t,o)||"Unknown channel"}`;default:return"Unknown source"}}static computeOwnershipReason(t,o,a,n){if(!a)return"You received this";switch(n){case"device":return t.source_device_iden===o.current_device_iden?"You sent this":"From your device";case"channel_broadcast":return`You own channel: ${this.getChannelName(t,o)||"Unknown channel"}`;case"channel_subscription":return"You received this from a channel";default:return"You own this"}}static async checkAndHandleUnknownSource(t){await F.isKnownSource(t.source_device_iden,t.channel_iden)||await F.handleUnknownSource(t.source_device_iden,t.channel_iden)}static async enrichPushesWithContextRefresh(t,o){for(const n of t)await this.checkAndHandleUnknownSource(n);const a=await F.getContext(o);return this.enrichPushes(t,a)}}async function O(e){try{if(!e.type||!["note","link","broadcast"].includes(e.type))throw new Error('Invalid push type. Must be "note", "link", or "broadcast"');if(e.type==="link"&&!e.url)throw new Error("URL is required for link pushes");if(e.type==="broadcast"&&!e.channel_tag)throw new Error("Channel tag is required for broadcast pushes");const t=await d("pb_token");if(!t)throw new Error("No token available");const o=await d("pb_device_iden");if(!o)throw new Error("Chrome device not registered");const a={type:e.type==="broadcast"?"note":e.type,source_device_iden:o};e.title&&(a.title=e.title),e.body&&(a.body=e.body),e.type==="link"&&(a.url=e.url),e.type==="broadcast"?a.channel_tag=e.channel_tag:e.targetDeviceIden?a.target_device_iden=e.targetDeviceIden:e.email&&(a.email=e.email);const n=await k.fetch("https://api.pushbullet.com/v2/pushes",{method:"POST",headers:{"Access-Token":t,"Content-Type":"application/json"},body:JSON.stringify(a)});if(!n.ok){if(n.status===401)throw await u(h.TokenRevoked,{message:"Token revoked while creating push",code:n.status}),new Error("Token is invalid or revoked");if(n.status===400){const s=await n.json();throw new Error(`Invalid push data: ${s.error?.message||"Bad request"}`)}throw new Error(`Failed to create push: ${n.status} ${n.statusText}`)}return await n.json()}catch(t){throw await u(h.Unknown,{message:"Failed to create push",code:t instanceof Error?void 0:500}),t}}async function W(e){try{if(e.size>26214400)throw new Error(`File size (${(e.size/1024/1024).toFixed(1)}MB) exceeds the 25MB limit`);const o=await d("pb_token");if(!o)throw new Error("No token available");const a={file_name:e.name,file_type:e.type||"application/octet-stream"},n=await k.fetch("https://api.pushbullet.com/v2/upload-request",{method:"POST",headers:{"Access-Token":o,"Content-Type":"application/json"},body:JSON.stringify(a)});if(!n.ok){if(n.status===401)throw await u(h.TokenRevoked,{message:"Token revoked while requesting upload",code:n.status}),new Error("Token is invalid or revoked");if(n.status===413)throw new Error("File too large for upload");if(n.status===400){const c=await n.json();throw new Error(`Invalid upload request: ${c.error?.message||"Bad request"}`)}throw new Error(`Failed to request upload: ${n.status} ${n.statusText}`)}const r=await n.json(),s={uploadUrl:r.upload_url,fileUrl:r.file_url,s3Fields:r.data};return console.log("Upload request successful:",s.fileUrl),s}catch(t){throw console.error("Failed to request upload:",t),await u(h.Unknown,{message:"Failed to request file upload",code:t instanceof Error?void 0:500}),t}}async function ve(e,t,o,a,n,r,s,c){try{const i=await d("pb_token");if(!i)throw new Error("No token available");const w=await d("pb_device_iden");if(!w)throw new Error("Chrome device not registered");const g={type:"file",file_name:t,file_type:o,file_url:e,source_device_iden:w};a&&(g.target_device_iden=a),c&&(g.email=c),n&&(g.title=n),r&&(g.body=r+" (File: "+t+")"),s&&(g.channel_tag=s);const m=await k.fetch("https://api.pushbullet.com/v2/pushes",{method:"POST",headers:{"Access-Token":i,"Content-Type":"application/json"},body:JSON.stringify(g)});if(!m.ok){if(m.status===401)throw await u(h.TokenRevoked,{message:"Token revoked while creating file push",code:m.status}),new Error("Token is invalid or revoked");if(m.status===400){const C=await m.json();throw new Error(`Invalid file push data: ${C.error?.message||"Bad request"}`)}throw new Error(`Failed to create file push: ${m.status} ${m.statusText}`)}const f=await m.json();return console.log("File push created successfully:",f.iden),f}catch(i){throw console.error("Failed to create file push:",i),await u(h.Unknown,{message:"Failed to create file push",code:i instanceof Error?void 0:500}),i}}async function x(e=200,t,o){try{const a=await d("pb_token");if(!a)throw new Error("No token available");const n=new URLSearchParams;n.append("limit",e.toString()),t&&n.append("modified_after",t.toString()),o&&n.append("cursor",o);const r=await k.fetch(`https://api.pushbullet.com/v2/pushes?${n}`,{method:"GET",headers:{"Access-Token":a,"Content-Type":"application/json"}});if(!r.ok)throw r.status===401?(await u(h.TokenRevoked,{message:"Token revoked while fetching push history",code:r.status}),new Error("Token is invalid or revoked")):new Error(`Failed to fetch push history: ${r.status} ${r.statusText}`);const s=await r.json();return{pushes:s.pushes,cursor:s.cursor}}catch(a){throw await u(h.Unknown,{message:"Failed to fetch push history",code:a instanceof Error?void 0:500}),a}}async function Se(e,t=200,o,a){try{const n=await d("pb_token");if(!n)throw new Error("No token available");const r=new URLSearchParams;r.append("limit",t.toString()),o&&r.append("modified_after",o.toString()),a&&r.append("cursor",a);const s=await k.fetch(`https://api.pushbullet.com/v2/pushes?${r}`,{method:"GET",headers:{"Access-Token":n,"Content-Type":"application/json"}});if(!s.ok)throw s.status===401?(await u(h.TokenRevoked,{message:"Token revoked while fetching push history",code:s.status}),new Error("Token is invalid or revoked")):new Error(`Failed to fetch push history: ${s.status} ${s.statusText}`);const c=await s.json();return{pushes:await kt.enrichPushesWithContextRefresh(c.pushes,e),cursor:c.cursor}}catch(n){throw await u(h.Unknown,{message:"Failed to fetch enhanced push history",code:n instanceof Error?void 0:500}),n}}async function z(e){const t=await d("pb_token");if(!t)throw new Error("No token available");const o=await k.fetch(`https://api.pushbullet.com/v2/pushes/${e}`,{method:"POST",headers:{"Access-Token":t,"Content-Type":"application/json"},body:JSON.stringify({dismissed:!0})});if(!o.ok)throw o.status===401?(await u(h.TokenRevoked,{message:"Token revoked while dismissing push",code:o.status}),new Error("Token is invalid or revoked")):new Error(`Failed to dismiss push: ${o.status} ${o.statusText}`)}async function Te(e){const t=await d("pb_token");if(!t)throw new Error("No token available");const o=await k.fetch(`https://api.pushbullet.com/v2/pushes/${e}`,{method:"DELETE",headers:{"Access-Token":t,"Content-Type":"application/json"}});if(!o.ok)throw o.status===401?(await u(h.TokenRevoked,{message:"Token revoked while deleting push",code:o.status}),new Error("Token is invalid or revoked")):new Error(`Failed to delete push: ${o.status} ${o.statusText}`)}const _t=Object.freeze(Object.defineProperty({__proto__:null,createFilePush:ve,createPush:O,deletePush:Te,dismissPush:z,getEnhancedPushHistory:Se,getPushHistory:x,requestUpload:W},Symbol.toStringTag,{value:"Module"})),p={socket:null,isConnected:!1,lastHeartbeat:0,retryCount:0,reconnectTimer:null,isPolling:!1,pollInterval:null},Ee=10,Y=[2e3,4e3,8e3,16e3,32e3],yt=6e4,bt=6e4;async function Ce(){try{if(!await d("pb_token")){console.log("No token available, skipping WebSocket initialization");return}await Fe()}catch(e){console.error("Failed to initialize WebSocket:",e),await u(h.Unknown,{message:"Failed to initialize WebSocket connection",code:e instanceof Error?void 0:500})}}async function Fe(){try{const e=await d("pb_token");if(!e)throw new Error("No token available");p.socket&&p.socket.close(),p.reconnectTimer&&(clearTimeout(p.reconnectTimer),p.reconnectTimer=null),p.pollInterval&&(clearInterval(p.pollInterval),p.pollInterval=null);const t=`wss://stream.pushbullet.com/websocket/${e}`;console.log("Connecting to WebSocket:",t),p.socket=new WebSocket(t),p.socket.onopen=vt,p.socket.onmessage=St,p.socket.onclose=Tt,p.socket.onerror=Et}catch(e){console.log("Failed to connect WebSocket:",e),await Pe()}}function vt(){console.log("WebSocket connected"),p.isConnected=!0,p.lastHeartbeat=Date.now(),p.retryCount=0,p.isPolling=!1,p.pollInterval&&(clearInterval(p.pollInterval),p.pollInterval=null)}function St(e){try{const t=JSON.parse(e.data);switch(console.log("WebSocket message received:",t.type),p.lastHeartbeat=Date.now(),t.type){case"nop":console.log("WebSocket heartbeat received");break;case"tickle":t.subtype==="push"?(console.log("Push tickle received, syncing history"),Me()):t.subtype==="device"?(console.log("Device tickle received, syncing history"),Ft()):t.subtype==="contact"&&(console.log("Contact tickle received, syncing contacts"),Pt());break;case"push":console.log("Push message received:",t.push?.type),Mt(t);break;default:console.log("Unknown WebSocket message type:",t.type)}}catch(t){console.error("Failed to parse WebSocket message:",t)}}async function Tt(e){console.log("WebSocket closed:",e.code,e.reason),p.isConnected=!1,p.socket=null,p.retryCount<Ee?await Pe():(console.log("Max retry count reached, switching to polling mode"),await Ct())}function Et(e){console.log("WebSocket connection error:",e),p.isConnected=!1}async function Pe(){p.retryCount++;const e=Y[Math.min(p.retryCount-1,Y.length-1)];console.log(`WebSocket connection failed, retry ${p.retryCount}/${Ee} in ${e}ms`),p.reconnectTimer=setTimeout(()=>{Fe()},e)}async function Ct(){p.isPolling||(console.log("Switching to polling mode due to WebSocket connection failures"),p.isPolling=!0,await u(h.Unknown,{message:"Real-time connection lost; falling back to polling.",code:1001}),p.pollInterval=setInterval(()=>{Me()},bt))}async function Me(){try{console.log("üîÑ [WebSocket] Push tickle received, syncing history with unified tracker");const e=await x(50,0,"");if(e.pushes&&e.pushes.length>0){console.log(`üîÑ [WebSocket] Found ${e.pushes.length} pushes to process`);let t=0,o=0;for(const a of e.pushes)!a.dismissed&&(a.receiver_iden||a.target_device_iden||a.type==="mirror"||a.type==="file"||a.channel_iden)&&(console.log(`üîî [WebSocket] Processing push: ${a.iden} (type: ${a.type}, created: ${a.created})`),await y.shouldShowNotification({id:a.iden,type:"push",created:a.created,metadata:{pushIden:a.iden}})?(console.log(`üÜï [WebSocket] New push detected: ${a.iden} (timestamp: ${a.created})`),await _.addPushNotifications(1),await y.markAsProcessed("push",a.iden,new Date(a.created).getTime()),o++):console.log(`‚è≠Ô∏è [WebSocket] Skipping already processed push: ${a.iden}`),t++);console.log(`üîÑ [WebSocket] Processed ${t} pushes, ${o} new pushes from tickle`)}}catch(e){console.error("Failed to handle push tickle:",e)}}async function Ft(){try{console.log("üîÑ [WebSocket] Device tickle received, refreshing devices directly"),await re(!0),console.log("üîÑ [WebSocket] Devices refreshed successfully")}catch(e){console.error("Failed to handle device tickle:",e)}}async function Pt(){try{console.log("üîÑ [WebSocket] Contact tickle received, refreshing contacts directly"),await U(!0),console.log("üîÑ [WebSocket] Contacts refreshed successfully")}catch(e){console.error("Failed to handle contact tickle:",e)}}async function Mt(e){try{const t=e.push;if(!t||!t.type){console.log("Invalid push message format");return}switch(t.type){case"mirror":console.log("Mirror push received, creating Chrome notification"),await ct(t);break;case"dismissal":console.log("Dismissal push received, clearing Chrome notification"),await lt(t);break;case"sms_changed":console.log("SMS changed push received, triggering SMS sync"),await $t(t);break;default:console.log("Unhandled push type:",t.type)}}catch(t){console.error("Failed to handle push message:",t),await u(h.Unknown,{message:"Failed to process push message",code:t instanceof Error?void 0:500})}}async function $t(e){try{console.log("üì± [WebSocket] SMS changed detected, triggering simple sync"),console.log("üì± [WebSocket] SMS changed push:",e);const t=await v();if(!t){console.warn("‚ö†Ô∏è [WebSocket] No SMS device for sync");return}await se(t.iden)}catch(t){console.error("üì± [WebSocket] Failed to handle SMS changed:",t)}}function $e(){return!p.isConnected||!p.socket?!1:Date.now()-p.lastHeartbeat<yt}function Ae(){return{isConnected:p.isConnected,isPolling:p.isPolling,retryCount:p.retryCount,lastHeartbeat:p.lastHeartbeat}}const De="keepalive",Ne="channel-refresh",Q=5,J=6;async function At(){try{await chrome.alarms.create(De,{periodInMinutes:Q}),console.log(`Keep-alive alarm created with ${Q} minute interval`),await chrome.alarms.create(Ne,{periodInMinutes:J*60}),console.log(`Channel refresh alarm created with ${J} hour interval`),chrome.alarms.onAlarm.addListener(Dt)}catch(e){console.error("Failed to initialize alarms:",e)}}function Dt(e){e.name===De?Nt():e.name===Ne&&It()}async function Nt(){console.log("keepalive - checking system health");try{const e=Ae(),t=$e();console.log("WebSocket status:",e),!t&&e.lastHeartbeat>0&&Date.now()-e.lastHeartbeat>6e4&&(console.log("WebSocket heartbeat stale, attempting reconnection"),await Ce()),await ye(),console.log("üîÑ [Alarm] Refreshing notification badge"),await _.refreshBadge(),e.retryCount>0&&console.log(`WebSocket reconnection attempts: ${e.retryCount}`)}catch(e){console.log("Keep-alive check failed:",e)}}async function It(){console.log("channel-refresh - refreshing channel data");try{await j(),console.log("Channel data refreshed successfully")}catch(e){console.error("Channel refresh failed:",e),await u(h.Unknown,{message:"Channel data refresh failed",code:e instanceof Error?void 0:500})}}async function Ut(e){try{let t;e.arrayBuffer&&typeof e.arrayBuffer=="function"?t=await e.arrayBuffer():t=await new Promise((n,r)=>{const s=new FileReader;s.onload=()=>n(s.result),s.onerror=()=>r(s.error),s.readAsArrayBuffer(e)});const o=await crypto.subtle.digest("SHA-256",t);return Array.from(new Uint8Array(o)).map(n=>n.toString(16).padStart(2,"0")).join("")}catch(t){return console.error("Failed to generate file hash:",t),`${Date.now()}-${e.size}-${e.name}`}}async function Ie(e,t,o,a=0){const n={fileHash:e,uploadInfo:t,offset:a,fileName:o.name,fileSize:o.size,fileType:o.type||"application/octet-stream",timestamp:Date.now(),attempts:0},r=await d("pb_pending_uploads")||[],s=r.findIndex(c=>c.fileHash===e);s>=0?r[s]=n:r.push(n),await l("pb_pending_uploads",r)}async function Ue(e){const o=(await d("pb_pending_uploads")||[]).filter(a=>a.fileHash!==e);await l("pb_pending_uploads",o)}async function Oe(e,t,o,a=0){const n=await Ut(t);try{await Ie(n,e,t,a);const r=new FormData;if(Object.entries(e.s3Fields).forEach(([c,i])=>{r.append(c,i)}),a>0){const c=t.slice(a);r.append("file",c,t.name)}else r.append("file",t);const s=await fetch(e.uploadUrl,{method:"POST",body:r});if(s.ok)return console.log("File upload completed successfully"),await Ue(n),o&&o({loaded:t.size,total:t.size,percentage:100}),{success:!0};{const c=`Upload failed with status ${s.status}: ${s.statusText}`;return console.error(c),s.status===413?(await u(h.FileTooLarge,{message:"File too large for upload",code:413}),{success:!1,error:"File too large for upload"}):s.status===400?(await u(h.InvalidUpload,{message:"Invalid upload request",code:400}),{success:!1,error:"Invalid upload request"}):(await u(h.Unknown,{message:"File upload failed",code:s.status}),{success:!1,error:"Upload failed"})}}catch(r){return console.error("Failed to upload file:",r),r instanceof TypeError&&r.message.includes("fetch")?(await u(h.NetworkError,{message:"Network error during file upload",code:void 0}),{success:!1,error:"Network error during upload"}):(await u(h.Unknown,{message:"Failed to upload file",code:r instanceof Error?void 0:500}),{success:!1,error:"Upload failed"})}}async function Ot(){try{const e=await d("pb_pending_uploads")||[];let t=0;for(const o of e){if(Date.now()-o.timestamp>3600*1e3){console.log("Skipping old pending upload:",o.fileName);continue}if(o.attempts>=3){console.log("Skipping upload with too many attempts:",o.fileName);continue}try{console.log(`Resuming upload for ${o.fileName} from offset ${o.offset}`),await Ue(o.fileHash),t++}catch(a){console.error("Failed to resume upload:",a),o.attempts++;const n=new File([],o.fileName,{type:o.fileType});Object.defineProperty(n,"size",{value:o.fileSize}),await Ie(o.fileHash,o.uploadInfo,n,o.offset)}}return t}catch(e){return console.error("Failed to resume interrupted uploads:",e),0}}async function xt(){try{const e=await d("pb_pending_uploads")||[],t=Date.now()-3600*1e3,o=e.filter(a=>a.timestamp>t);o.length!==e.length&&(await l("pb_pending_uploads",o),console.log(`Cleaned up ${e.length-o.length} old pending uploads`))}catch(e){console.error("Failed to cleanup old pending uploads:",e)}}const S={isOnline:!0,isProcessing:!1,processingInterval:null},Bt=5e3,X=3;async function Z(e){try{const t={...e,id:jt(),timestamp:Date.now(),retryCount:0},o=await d("pb_pending_ops")||[];o.push(t),await l("pb_pending_ops",o),console.log("Operation queued:",t.type,t.id),S.isOnline&&await xe()}catch(t){console.error("Failed to enqueue operation:",t),await u(h.Unknown,{message:"Failed to queue operation",code:t instanceof Error?void 0:500})}}async function xe(){if(!S.isProcessing){S.isProcessing=!0;try{const e=await d("pb_pending_ops")||[];if(e.length===0)return;console.log(`Processing ${e.length} queued operations`);for(const t of e)try{await Lt(t);const o=e.filter(a=>a.id!==t.id);await l("pb_pending_ops",o),await new Promise(a=>setTimeout(a,Bt))}catch(o){if(console.error("Failed to process operation:",t.id,o),t.retryCount++,t.retryCount>=X){console.log("Operation exceeded max retries, removing from queue:",t.id);const a=e.filter(n=>n.id!==t.id);await l("pb_pending_ops",a),await u(h.Unknown,{message:`Operation failed after ${X} retries: ${t.type}`,code:1002})}else{const a=e.map(n=>n.id===t.id?t:n);await l("pb_pending_ops",a)}}}catch(e){console.error("Failed to process queue:",e)}finally{S.isProcessing=!1}}}async function Lt(e){switch(e.type){case"pushSend":await O(e.payload);break;case"smsSend":throw new Error("SMS sending not yet implemented");case"dismissal":throw new Error("Dismissal not yet implemented");default:throw new Error(`Unknown operation type: ${e.type}`)}}async function Ht(){return{pendingCount:(await d("pb_pending_ops")||[]).length,isOnline:S.isOnline,isProcessing:S.isProcessing}}async function Gt(){await l("pb_pending_ops",[]),console.log("Operation queue cleared")}function jt(){return`op_${Date.now()}_${Math.random().toString(36).substr(2,9)}`}function Wt(){S.processingInterval=setInterval(()=>{S.isProcessing||xe()},5e3),console.log("Operation queue system initialized")}const zt=4*1024*1024,ee=12,Be="quota-check",L="pb_push_history",H="pb_transfers",qt="pb_settings";async function Rt(){try{await chrome.alarms.create(Be,{periodInMinutes:ee*60}),console.log(`Quota monitor initialized with ${ee} hour interval`),chrome.alarms.onAlarm.addListener(Vt),await Le()}catch(e){console.error("Failed to initialize quota monitor:",e)}}function Vt(e){e.name===Be&&Le()}async function Le(){try{const e=await Ve();console.log(`Storage quota check: ${e} bytes used`),e>zt&&(console.log("Storage quota exceeded, purging old data..."),await Kt(),await u(h.QuotaExceeded,{message:`Storage quota exceeded (${Math.round(e/1024/1024*100)/100} MB used)`,code:e}))}catch(e){console.error("Failed to check quota:",e)}}async function Kt(){const e=Date.now(),t=e-2160*60*60*1e3,o=e-720*60*60*1e3;let a=0;try{const n=await d(L)||[],r=n.filter(g=>g.timestamp>t);r.length<n.length&&(await l(L,r),a+=n.length-r.length,console.log(`Purged ${n.length-r.length} old push history entries`));const s=await d(H)||[],c=s.filter(g=>g.timestamp>o);c.length<s.length&&(await l(H,c),a+=s.length-c.length,console.log(`Purged ${s.length-c.length} old transfer entries`));const w=(await Yt()).filter(g=>g.startsWith("mirror_"));for(const g of w){const m=await d(g);m&&m.timestamp&&m.timestamp<o&&(await D(g),a++)}console.log(`Quota purge completed: ${a} items removed`)}catch(n){throw console.error("Failed to purge old data:",n),n}}async function Yt(){return[L,H,qt,"pb_token","pb_device_iden","pb_last_modified"]}const te=6,He="token-health-check";async function Qt(){try{await chrome.alarms.create(He,{periodInMinutes:te*60}),console.log(`Token health monitor initialized with ${te} hour interval`),chrome.alarms.onAlarm.addListener(Jt),await Ge()}catch(e){console.error("Failed to initialize token health monitor:",e)}}function Jt(e){e.name===He&&Ge()}async function Ge(){try{const e=await d("pb_token");if(!e)return console.log("No token found for health check"),{isValid:!1,lastChecked:Date.now(),error:"No token found"};console.log("Checking token health...");const t=await k.fetch("https://api.pushbullet.com/v2/users/me",{method:"GET",headers:{"Access-Token":e,"Content-Type":"application/json"}}),o={isValid:t.ok,lastChecked:Date.now()};if(t.ok){const a=await t.json();console.log("Token health check passed for user:",a.name),await l("pb_token_health",o)}else t.status===401?(console.error("Token health check failed: Token revoked"),o.error="Token revoked",await Xt()):(console.error("Token health check failed:",t.status,t.statusText),o.error=`API error: ${t.status}`);return await l("pb_token_health",o),o}catch(e){console.error("Token health check error:",e);const t={isValid:!1,lastChecked:Date.now(),error:e instanceof Error?e.message:"Unknown error"};return await l("pb_token_health",t),t}}async function Xt(){try{console.log("Handling token revocation..."),await u(h.TokenRevoked,{message:"Token has been revoked by Pushbullet",code:401}),await l("pb_token",""),await l("pb_device_iden",""),await chrome.action.setBadgeText({text:"AUTH"}),await chrome.action.setBadgeBackgroundColor({color:"#ef4444"}),console.log("Token revocation handled")}catch(e){console.error("Failed to handle token revocation:",e)}}console.log("Pushbridge background service worker started");const oe="pb_last_popup_opened",Zt=36e5;async function eo(){try{const e=["pb_recent_pushes_state","pb_devices_cursor","pb_devices_has_more","pb_subscriptions_cursor","pb_subscriptions_has_more","pb_channels_cursor","pb_channels_has_more","pb_contacts_cursor","pb_contacts_has_more"];for(const a of e)await l(a,null);const t=await chrome.storage.local.get(null),o=Object.keys(t).filter(a=>a.startsWith("pb_sms_thread_cursor_"));for(const a of o)await chrome.storage.local.remove(a);console.log("All cursors cleared")}catch(e){console.error("Failed to clear cursors:",e)}}async function to(){try{console.log("[Background] Initializing SMS sync...");const e=await v();e?(console.log(`[Background] Default SMS device: ${e.nickname} (${e.iden})`),console.log(`[Background] SMS-capable device found: ${e.nickname}`),setInterval(async()=>{await q("periodic")},360*60*1e3),console.log("[Background] SMS sync initialized with 6-hour interval")):console.log("[Background] No SMS-capable device found, skipping SMS sync")}catch(e){console.error("[Background] Failed to initialize SMS sync:",e)}}chrome.runtime.onInstalled.addListener(async()=>{console.log("Pushbridge extension installed");try{await k.initialize(),await R.loadState(),console.log("[Background] Rate limit manager initialized"),V.initialize(),console.log("[Background] Token bucket initialized"),setInterval(()=>{const t=R.getDebugInfo(),o=V.getDetailedStatus();(t.isBackoffActive||t.backoffState.isActive)&&console.log("[Background] Backoff debug info:",t),o.bucket<=10&&console.log("[Background] Token bucket status:",o)},1e4),setInterval(async()=>{try{await y.validateState()||console.warn("[Background] Unified notification tracker state validation failed")}catch(t){console.error("[Background] Failed to validate unified notification tracker state:",t)}},300*1e3),await At(),await Rt(),await Qt(),Wt(),await we(),await to(),console.log("[Background] SMS sync using simple system"),await F.loadContext(),console.log("[Background] Context manager initialized"),await y.initialize(),await Ce(),await _e();const e=await Ot();e>0&&console.log(`Resumed ${e} interrupted uploads`),await xt(),await So()}catch(e){console.error("Failed to initialize background services:",e)}});chrome.runtime.onStartup.addListener(async()=>{console.log("Pushbridge service worker started");try{await _e(),await ye()}catch(e){console.error("Failed to handle service worker startup:",e)}});chrome.notifications.onClicked.addListener(async e=>{try{const t=await d(`notification_${e}`);if(!t){console.log("No notification data found for:",e);return}t.url?await chrome.tabs.create({url:t.url}):await chrome.action.openPopup(),await l(`notification_${e}`,null)}catch(t){console.error("Failed to handle notification click:",t)}});chrome.notifications.onButtonClicked.addListener(async(e,t)=>{try{const o=await d(`notification_${e}`);if(!o)return;t===0&&(await z(o.pushIden),await chrome.notifications.clear(e),await l(`notification_${e}`,null))}catch(o){console.error("Failed to handle notification button click:",o)}});chrome.notifications.onClicked.addListener(async e=>{if(e.includes("-")&&e.length===36)await ke(e);else try{const o=await d(`notification_${e}`);if(!o){console.log("No notification data found for:",e);return}o.url?await chrome.tabs.create({url:o.url}):await chrome.action.openPopup(),await l(`notification_${e}`,null)}catch(o){console.error("Failed to handle notification click:",o)}});chrome.notifications.onClosed.addListener(async(e,t)=>{t&&e.includes("-")&&e.length===36&&await ke(e)});chrome.runtime.onMessage.addListener((e,t,o)=>{switch(console.log("üì® [Background] Received message:",e),e.cmd){case"verifyToken":oo(e.token,o);break;case"getDevices":ao(e.forceRefresh,o);break;case"clearDeviceCache":no(o);break;case"getContacts":ro(e.forceRefresh,o);break;case"clearContactCache":so(o);break;case"createPush":io(e.payload,o);break;case"getPushHistory":co(e.limit,e.modifiedAfter,e.cursor,o);break;case"getEnhancedPushHistory":lo(e.trigger,e.limit,e.modifiedAfter,e.cursor,o);break;case"dismissPush":uo(e.pushIden,o);break;case"deletePush":ho(e.pushIden,o);break;case"syncHistory":fo(o);break;case"getQueueStatus":wo(o);break;case"clearQueue":mo(o);break;case"getActiveMirrors":ko(o);break;case"POPUP_OPEN":qo(o);break;case"CLEAR_SMS_NOTIFICATIONS":Go(o);break;case"UPLOAD_FILE":_o(e.payload,o);break;case"UPLOAD_FILE_FOR_SMS":yo(e.payload,o);break;case"GET_TRANSFERS":bo(o);break;case"DOWNLOAD_FILE":vo(e.payload,o);break;case"GET_SMS_CONVERSATIONS":case"GET_SMS_CONVERSATIONS_FROM_API":To(o);break;case"GET_SMS_THREAD":case"GET_SMS_THREAD_FROM_API":case"LOAD_FULL_SMS_THREAD":ae(e.conversationId,e.deviceIden,o);break;case"GET_SMS_THREAD_PAGED":ae(e.conversationId,e.deviceIden,o);break;case"SEND_SMS":Do(e.payload.conversationId,e.payload.message,o,e.payload.deviceIden,e.payload.attachments);break;case"MARK_CONVERSATION_READ":Eo(e.conversationId,o);break;case"GET_DEFAULT_SMS_DEVICE":Co(o);break;case"GET_SMS_CAPABLE_DEVICES":Fo(o);break;case"SET_DEFAULT_SMS_DEVICE":Po(e.deviceIden,o);break;case"SYNC_SMS_HISTORY":Mo(e.deviceIden,o);break;case"RELOAD_SMS_THREAD":$o(e.deviceIden,e.threadId,o);break;case"GET_SMS_DEVICE_INFO":Ao(o);break;case"GET_CHANNEL_SUBSCRIPTIONS":No(e.forceRefresh,o);break;case"SUBSCRIBE_TO_CHANNEL":Io(e.channelTag,o);break;case"UNSUBSCRIBE_FROM_CHANNEL":Uo(e.subscriptionIden,o);break;case"GET_CHANNEL_INFO":Oo(e.channelTag,o);break;case"GET_OWNED_CHANNELS":Bo(o);break;case"REFRESH_CHANNEL_DATA":Lo(o);break;case"GET_SUBSCRIPTION_POSTS":Ho(o);break;case"clearAllData":jo(o);break;case"testWebSocket":Wo(o);break;case"getDebugLog":zo(o);break;case"getUnifiedTrackerState":Vo(o);break;case"DEBUG_SMS":case"DEBUG_STORAGE":o({success:!1,error:"Debug functions removed in simple system"});break;default:o({status:"unknown_command"})}return!0});async function oo(e,t){try{const o=await k.fetch("https://api.pushbullet.com/v2/users/me",{method:"GET",headers:{"Access-Token":e,"Content-Type":"application/json"}});if(o.ok){const a=await o.json();console.log("Token verified successfully for user:",a.name),await l("pb_token",e),await l("pb_user_iden",a.iden);try{const n=await Ke();console.log("Chrome device registered:",n),t({ok:!0,user:a,deviceIden:n})}catch(n){console.error("Device registration failed:",n),t({ok:!0,user:a,deviceError:"Device registration failed"})}}else o.status===401?(console.error("Token verification failed: Unauthorized"),await u(h.TokenRevoked,{message:"Token is invalid or revoked",code:o.status}),t({ok:!1,error:"Invalid token. Please check your Pushbullet access token."})):(console.error("Token verification failed:",o.status,o.statusText),await u(h.Unknown,{message:"Token verification failed",code:o.status}),t({ok:!1,error:"Token verification failed. Please try again."}))}catch(o){console.error("Token verification error:",o),await u(h.Unknown,{message:"Token verification failed"}),t({ok:!1,error:"Failed to verify token. Please check your internet connection."})}}async function ao(e,t){try{const o=await Ye(e);t({ok:!0,devices:o})}catch(o){console.error("Failed to get devices:",o),t({ok:!1,error:"Failed to fetch devices"})}}async function no(e){try{await ie(),e({ok:!0})}catch(t){console.error("Failed to clear device cache:",t),e({ok:!1,error:"Failed to clear cache"})}}async function ro(e,t){try{const o=await U(e);t({ok:!0,contacts:o})}catch(o){console.error("Failed to get contacts:",o),t({ok:!1,error:"Failed to fetch contacts"})}}async function so(e){try{await be(),e({ok:!0})}catch(t){console.error("Failed to clear contact cache:",t),e({ok:!1,error:"Failed to clear contact cache"})}}async function io(e,t){try{if(!$e()){await Z({type:"pushSend",payload:e}),t({ok:!0,queued:!0,message:"Push queued for later delivery"});return}const o=await O(e);try{chrome.runtime.sendMessage({cmd:"pushCreated",source:"background",push:o})}catch{}t({ok:!0,push:o})}catch(o){if(console.error("Failed to create push:",o),o instanceof Error&&o.message.includes("network")){await Z({type:"pushSend",payload:e}),t({ok:!0,queued:!0,message:"Push queued due to network error"});return}t({ok:!1,error:o instanceof Error?o.message:"Failed to create push"})}}async function co(e,t,o,a){try{const n=await x(e,t,o);if(console.log("üìã [handleGetPushHistory] Response:",{ok:!0,history:n.pushes.length,modifiedAfter:t,cursor:o}),n.pushes.length>0){const r=Math.max(...n.pushes.map(s=>s.modified));await l("pb_last_modified",r)}a({ok:!0,history:n})}catch(n){console.error("Failed to get push history:",n),a({ok:!1,error:"Failed to fetch push history"})}}async function lo(e,t,o,a,n){try{console.log("üîÑ [Background] Getting enhanced push history with trigger:",e.type);const r=await Se(e,t,o,a);if(console.log("üìã [handleGetEnhancedPushHistory] Response:",{ok:!0,history:r.pushes.length,modifiedAfter:o,cursor:a,trigger:e.type}),r.pushes.length>0){const s=Math.max(...r.pushes.map(c=>c.modified));if(await l("pb_last_modified",s),console.log("üîç [Background] Enhanced push details:",r.pushes.map(c=>({iden:c.iden,type:c.type,title:c.title,receiver_iden:c.receiver_iden,target_device_iden:c.target_device_iden,dismissed:c.dismissed,created:c.created,modified:c.modified,channel_iden:c.channel_iden}))),e.type==="unknown_source"){console.log("üîî [Background] Processing pushes for notifications (WebSocket tickle)");let c=0;for(const i of r.pushes)!i.dismissed&&(i.receiver_iden||i.target_device_iden||i.type==="mirror"||i.type==="file"||i.channel_iden)?await y.shouldShowNotification({id:i.iden,type:"push",created:i.created,metadata:{pushIden:i.iden}})?(console.log(`üîî [Background] Processing new push: ${i.iden} (type: ${i.type})`),(await je(i)||i.type==="file"||i.channel_iden)&&(console.log("üîî [Background] Updating badge for new push notification"),await _.addPushNotifications(1),await y.markAsProcessed("push",i.iden,new Date(i.created).getTime()),c++)):console.log(`‚è≠Ô∏è [Background] Skipping already processed push: ${i.iden}`):console.log(`‚è≠Ô∏è [Background] Skipping push: ${i.iden} (dismissed: ${i.dismissed})`);console.log(`üìä [Background] New push processing summary: ${c} new notifications`)}else console.log(`‚è≠Ô∏è [Background] Skipping notification processing for trigger: ${e.type} (popup open)`)}else console.log("üîÑ [Background] No new pushes found in enhanced history");n({ok:!0,history:r})}catch(r){console.error("Failed to get enhanced push history:",r),n({ok:!1,error:"Failed to fetch enhanced push history"})}}async function uo(e,t){try{await z(e),console.log("üîî [Background] Push dismissed, updating badge"),await _.addPushNotifications(-1),t({ok:!0})}catch(o){console.error("Failed to dismiss push:",o),t({ok:!1,error:"Failed to dismiss push"})}}async function ho(e,t){try{await Te(e),console.log("üîî [Background] Push deleted, updating badge"),await _.addPushNotifications(-1),t({ok:!0})}catch(o){console.error("Failed to delete push:",o),t({ok:!1,error:"Failed to delete push"})}}async function fo(e){try{console.log("üîÑ [Background] Syncing push history");const t=await d("pb_last_modified"),o=await chrome.storage.local.get("pb_recent_pushes_state"),a=o.pb_recent_pushes_state?.cursor,n=await x(100,t,a);if(n.pushes.length>0){console.log(`üîÑ [Background] Found ${n.pushes.length} pushes from API`),console.log("üîç [Background] Push details:",n.pushes.map(i=>({iden:i.iden,type:i.type,title:i.title,receiver_iden:i.receiver_iden,target_device_iden:i.target_device_iden,dismissed:i.dismissed,created:i.created,modified:i.modified})));const r=Math.max(...n.pushes.map(i=>i.modified));if(await l("pb_last_modified",r),n.cursor){const i=o.pb_recent_pushes_state||{};await chrome.storage.local.set({pb_recent_pushes_state:{...i,cursor:n.cursor,hasMore:!!n.cursor}})}let s=0,c=0;for(const i of n.pushes)!i.dismissed&&(i.receiver_iden||i.target_device_iden||i.type==="mirror"||i.type==="file"||i.channel_iden)?await y.shouldShowNotification({id:i.iden,type:"push",created:i.created,metadata:{pushIden:i.iden}})?(console.log(`üîî [Background] Processing push: ${i.iden} (type: ${i.type})`),(await je(i)||i.type==="file"||i.channel_iden)&&(console.log("üîî [Background] Updating badge for new push notification"),await _.addPushNotifications(1),await y.markAsProcessed("push",i.iden,new Date(i.created).getTime())),s++):(console.log(`‚è≠Ô∏è [Background] Skipping already processed push: ${i.iden}`),c++):(console.log(`‚è≠Ô∏è [Background] Skipping push: ${i.iden} (dismissed: ${i.dismissed}, receiver_iden: ${i.receiver_iden}, target_device_iden: ${i.target_device_iden})`),c++);console.log(`üìä [Background] Push processing summary: ${s} processed, ${c} skipped`)}else console.log("üîÑ [Background] No new pushes found");try{chrome.runtime.sendMessage({cmd:"syncHistory",source:"background",newPushes:n.pushes.length})}catch{}e({ok:!0,newPushes:n.pushes.length})}catch(t){console.error("Failed to sync history:",t),e({ok:!1,error:"Failed to sync history"})}}async function je(e){try{console.log("üîî [Background] Showing push notification:",{type:e.type,title:e.title,channel_tag:e.channel_tag});const t=await d("pb_device_iden");if(e.receiver_iden!==t)return console.log("üîî [Background] Push not for this device, skipping notification"),!1;let o,a,n;if(e.type==="file"){o="File received",a=e.file_name||"New file",n="/icons/48.png";const s={id:e.iden,type:"received",fileName:e.file_name,fileSize:0,fileType:e.file_type||"application/octet-stream",timestamp:Date.now(),status:"completed",sourceDevice:e.source_device_iden};await We(s),await po(e)}else e.channel_tag?(o=`${e.channel_tag}: ${e.title??"New post"}`,a=e.body??"",n="/icons/48.png",await go(e)):(o=e.title||(e.type==="link"?e.url:"New push"),a=e.body||"",n="/icons/48.png");const r=`push_${e.iden}`;return await chrome.notifications.create(r,{type:"basic",iconUrl:n,title:o,message:a,requireInteraction:!0}),await l(`notification_${r}`,{pushIden:e.iden,url:e.url,type:e.type,channelTag:e.channel_tag}),console.log("üîî [Background] Updating badge for new push notification"),await _.addPushNotifications(1),console.log("üîî [Background] Push notification created:",r),!0}catch(t){return console.error("Failed to show push notification:",t),!1}}async function po(e){try{await chrome.downloads.download({url:e.file_url,filename:e.file_name}),await chrome.notifications.create({type:"basic",iconUrl:"/icons/48.png",title:"File Downloaded",message:`File "${e.file_name}" has been downloaded`})}catch(t){console.error("Failed to download received file:",t),await chrome.notifications.create({type:"basic",iconUrl:"/icons/48.png",title:"File Available",message:`Click to view file "${e.file_name}"`})}}async function go(e){try{const t=await d("pb_recent_pushes")||[],o={...e,isChannelPush:!0,channelTag:e.channel_tag};t.unshift(o),t.length>500&&t.splice(500),await l("pb_recent_pushes",t)}catch(t){console.error("Failed to add channel push to recent list:",t)}}async function wo(e){try{const t=await Ht(),o=Ae();e({ok:!0,queue:t,connection:o})}catch(t){console.error("Failed to get queue status:",t),e({ok:!1,error:"Failed to get queue status"})}}async function mo(e){try{await Gt(),e({ok:!0})}catch(t){console.error("Failed to clear queue:",t),e({ok:!1,error:"Failed to clear queue"})}}async function ko(e){try{const t=await ht();e({success:!0,mirrors:t})}catch(t){console.error("Failed to get active mirrors:",t),e({success:!1,error:"Failed to fetch notifications"})}}async function We(e){try{const t=await d("pb_transfers")||[];t.unshift(e),t.length>50&&t.splice(50),await l("pb_transfers",t)}catch(t){console.error("Failed to add transfer record:",t)}}async function _o(e,t){try{const{fileData:o,targetDeviceIden:a,email:n,title:r,body:s,channel_tag:c}=e,i=new File([new Uint8Array(o.buffer)],o.name,{type:o.type,lastModified:o.lastModified}),w=await W(i),m=await Oe(w,i,f=>{chrome.runtime.sendMessage({type:"UPLOAD_PROGRESS",payload:{progress:f.percentage}}).catch(()=>{})});if(m.success){const f=await ve(w.fileUrl,i.name,i.type||"application/octet-stream",a,r,s,c,n),C={id:f.iden,type:"sent",fileName:i.name,fileSize:i.size,fileType:i.type||"application/octet-stream",timestamp:Date.now(),status:"completed",targetDevice:a};await We(C);try{chrome.runtime.sendMessage({cmd:"pushCreated",source:"background",push:f})}catch{}await chrome.notifications.create({type:"basic",iconUrl:"/icons/48.png",title:"File Sent",message:`File "${i.name}" sent successfully`}),t({success:!0,filePush:f})}else t({success:!1,error:m.error})}catch(o){console.error("Failed to upload file:",o),t({success:!1,error:o instanceof Error?o.message:"Upload failed"})}}async function yo(e,t){try{const{fileData:o}=e,a=new File([new Uint8Array(o.buffer)],o.name,{type:o.type,lastModified:o.lastModified}),n=await W(a),s=await Oe(n,a,c=>{chrome.runtime.sendMessage({type:"UPLOAD_PROGRESS",payload:{progress:c.percentage}}).catch(()=>{})});s.success?t({success:!0,fileUrl:n.fileUrl}):t({success:!1,error:s.error})}catch(o){console.error("Failed to upload file for SMS:",o),t({success:!1,error:o instanceof Error?o.message:"Upload failed"})}}async function bo(e){try{const t=await d("pb_transfers")||[];e({success:!0,transfers:t})}catch(t){console.error("Failed to get transfers:",t),e({success:!1,error:"Failed to load transfers"})}}async function vo(e,t){try{if(!(await d("pb_transfers")||[]).find(n=>n.id===e.transferId)){t({success:!1,error:"Transfer not found"});return}await chrome.notifications.create({type:"basic",iconUrl:"/icons/48.png",title:"Download Not Available",message:"File download will be implemented in a future update"}),t({success:!0})}catch(o){console.error("Failed to download file:",o),t({success:!1,error:"Download failed"})}}async function So(){chrome.contextMenus.removeAll(async()=>{try{const e=await re(),t=await U(),o=[{id:"push-page",title:"Push this page",contexts:["page"]},{id:"push-link",title:"Push this link",contexts:["link"]},{id:"push-image",title:"Push this image",contexts:["image"]},{id:"push-selection",title:"Push selected text",contexts:["selection"]}];for(const a of o){if(chrome.contextMenus.create({id:a.id,title:a.title,contexts:a.contexts}),e.length>0){chrome.contextMenus.create({id:`${a.id}-devices`,title:"Devices",parentId:a.id,contexts:a.contexts});for(const n of e)chrome.contextMenus.create({id:`${a.id}-device-${n.iden}`,title:`üì± ${n.nickname}`,parentId:`${a.id}-devices`,contexts:a.contexts})}if(t.length>0){chrome.contextMenus.create({id:`${a.id}-contacts`,title:"Contacts",parentId:a.id,contexts:a.contexts});for(const n of t)chrome.contextMenus.create({id:`${a.id}-contact-${n.iden}`,title:`üë§ ${n.name}`,parentId:`${a.id}-contacts`,contexts:a.contexts})}chrome.contextMenus.create({id:`${a.id}-all`,title:"üì§ All Devices",parentId:a.id,contexts:a.contexts})}}catch(e){console.error("Failed to create context menus:",e),chrome.contextMenus.create({id:"push-page-all",title:"Push this page",contexts:["page"]})}})}chrome.contextMenus.onClicked.addListener(async(e,t)=>{if(t)try{const o=e.menuItemId;let a;const[n,r]=o.split("-");switch(n){case"push":switch(`${n}-${r}`){case"push-page":a={type:"link",url:t.url,title:t.title,body:`Page shared from ${new URL(t.url).hostname}`};break;case"push-link":a={type:"link",url:e.linkUrl,title:e.linkText||e.linkUrl,body:`Link shared from ${new URL(t.url).hostname}`};break;case"push-image":a={type:"link",url:e.srcUrl,title:e.altText||"Image",body:`Image shared from ${new URL(t.url).hostname}`};break;case"push-selection":a={type:"note",body:e.selectionText,title:`Text from ${new URL(t.url).hostname}`};break;default:return}break;default:return}if(o.includes("-device-")){const s=o.substring(o.lastIndexOf("-")+1);a.targetDeviceIden=s}else if(o.includes("-contact-")){const s=o.substring(o.lastIndexOf("-")+1),c=await wt(s);c&&(a.email=c.email)}else o.endsWith("-all");await O(a),await chrome.notifications.create({type:"basic",iconUrl:"/icons/48.png",title:"Push Sent",message:"Your push has been sent successfully!"})}catch(o){console.error("Failed to handle context menu click:",o),await chrome.notifications.create({type:"basic",iconUrl:"/icons/48.png",title:"Push Failed",message:"Failed to send push. Please try again."})}});async function To(e){try{console.log("üì± [Background] Getting SMS conversations (simple) - returning cached data");const t=await v();if(!t){e({success:!1,error:"No SMS device available"});return}const o=await Qe(t.iden);e({success:!0,conversations:o.threads,lastSync:o.lastSync})}catch(t){console.error("[Background] Failed to get SMS conversations:",t),e({success:!1,error:t instanceof Error?t.message:"Failed to get conversations"})}}async function ae(e,t,o){try{console.log(`üì® [Background] Getting SMS thread: ${e} (simple)`);let a=t;if(!a){const r=await v();if(!r){o({success:!1,error:"No SMS device available"});return}a=r.iden}console.log("üì® [Background] Loading thread from cache (no sync needed)");const n=await Je(a,e);o(n?{success:!0,thread:n}:{success:!1,error:"Thread not found"})}catch(a){console.error("[Background] Failed to get SMS thread:",a),o({success:!1,error:a instanceof Error?a.message:"Failed to get thread"})}}async function q(e="manual"){try{console.log(`üîÑ [Background] Triggering SMS sync (${e})`);const t=await v();if(!t){console.warn("‚ö†Ô∏è [Background] No SMS device for sync");return}await se(t.iden)}catch(t){console.error(`‚ùå [Background] SMS sync failed (${e}):`,t)}}async function Eo(e,t){try{console.log(`[Background] Marking conversation ${e} as read`),t({success:!0})}catch(o){console.error("Failed to mark conversation as read:",o),t({success:!1,error:"Failed to mark as read"})}}async function Co(e){try{console.log("[Background] Getting default SMS device...");const t=await v();t?(console.log("[Background] Default SMS device found:",{iden:t.iden,nickname:t.nickname,has_sms:t.has_sms}),e({success:!0,device:{iden:t.iden,nickname:t.nickname,has_sms:t.has_sms}})):(console.warn("[Background] No SMS-capable device found"),e({success:!1,error:"No SMS-capable device found"}))}catch(t){console.error("[Background] Failed to get default SMS device:",t),e({success:!1,error:"Failed to get SMS device"})}}async function Fo(e){try{const t=await Xe();e({success:!0,devices:t})}catch(t){console.error("Failed to get SMS-capable devices:",t),e({success:!1,error:"Failed to get devices"})}}async function Po(e,t){try{const o=await Ze(e);t({success:o})}catch(o){console.error("Failed to set default SMS device:",o),t({success:!1,error:"Failed to set device"})}}async function Mo(e,t){try{await q("manual"),t({success:!0})}catch(o){console.error("Failed to sync SMS history:",o),t({success:!1,error:"Failed to sync history"})}}async function $o(e,t,o){try{if(console.log(`üì± [Background] Reloading SMS thread: ${t} for device: ${e}`),!e){const n=await v();if(!n){o({success:!1,error:"No SMS device available"});return}e=n.iden}if(!t){o({success:!1,error:"Thread ID is required"});return}const a=await et(e,t);o(a?{success:!0,thread:a}:{success:!1,error:"Failed to reload thread - device may be offline or thread not found"})}catch(a){console.error("[Background] Failed to reload SMS thread:",a),o({success:!1,error:a instanceof Error?a.message:"Failed to reload SMS thread"})}}async function Ao(e){try{const t=await v();e(t?{success:!0,device:{iden:t.iden,nickname:t.nickname,model:t.model,type:t.type}}:{success:!1,error:"No SMS device found"})}catch(t){console.error("Failed to get SMS device info:",t),e({success:!1,error:"Failed to get device info"})}}async function Do(e,t,o,a,n){try{console.log("üì± [Background] Sending SMS:",{conversationId:e,messageLength:t.length,deviceIden:a,hasAttachments:!!n});let r=a;if(!r){const s=await v();if(!s){o({success:!1,error:"No SMS device available"});return}r=s.iden}if(!t.trim()&&(!n||n.length===0)){o({success:!1,error:"Message cannot be empty"});return}await tt(r,e,t,n),console.log("üì± [Background] SMS sent successfully to:",e),o({success:!0})}catch(r){console.error("üì± [Background] Failed to send SMS:",r),r instanceof Error?r.message.includes("Token is invalid or revoked")?o({success:!1,error:"Token is invalid or revoked"}):r.message.includes("Message cannot be empty")?o({success:!1,error:"Message cannot be empty"}):o({success:!1,error:r.message}):o({success:!1,error:"Failed to send SMS"})}}async function No(e,t){try{const{getSubscriptions:o}=await E(async()=>{const{getSubscriptions:n}=await Promise.resolve().then(()=>I);return{getSubscriptions:n}},void 0),a=await o(e);t({success:!0,subscriptions:a})}catch(o){console.error("Failed to get channel subscriptions:",o),t({success:!1,error:"Failed to fetch channel subscriptions"})}}async function Io(e,t){try{const o=await d("pb_token");if(!o){t({success:!1,error:"No access token available"});return}const a=await k.fetch("https://api.pushbullet.com/v2/subscriptions",{method:"POST",headers:{"Access-Token":o,"Content-Type":"application/json"},body:JSON.stringify({channel_tag:e})});if(!a.ok){if(a.status===401){await u(h.TokenRevoked,{message:"Token revoked during channel subscription",code:a.status}),t({success:!1,error:"Token is invalid or revoked"});return}throw new Error(`Failed to subscribe: ${a.status} ${a.statusText}`)}const n=await a.json(),{getSubscriptions:r}=await E(async()=>{const{getSubscriptions:s}=await Promise.resolve().then(()=>I);return{getSubscriptions:s}},void 0);await r(!0),t({success:!0,subscription:n})}catch(o){console.error("Failed to subscribe to channel:",o),t({success:!1,error:"Failed to subscribe to channel"})}}async function Uo(e,t){try{const o=await d("pb_token");if(!o){t({success:!1,error:"No access token available"});return}const{getSubscriptions:a}=await E(async()=>{const{getSubscriptions:i}=await Promise.resolve().then(()=>I);return{getSubscriptions:i}},void 0),r=(await a(!1)).find(i=>i.iden===e),s=r?.channel?.iden,c=await k.fetch(`https://api.pushbullet.com/v2/subscriptions/${e}`,{method:"DELETE",headers:{"Access-Token":o,"Content-Type":"application/json"}});if(!c.ok){if(c.status===404){const{clearSubscriptionsCache:i}=await E(async()=>{const{clearSubscriptionsCache:w}=await Promise.resolve().then(()=>I);return{clearSubscriptionsCache:w}},void 0);await i(),await ne(s,r),t({success:!0,message:"Already unsubscribed"});return}if(c.status===401){await u(h.TokenRevoked,{message:"Token revoked during channel unsubscription",code:c.status}),t({success:!1,error:"Token is invalid or revoked"});return}throw new Error(`Failed to unsubscribe: ${c.status} ${c.statusText}`)}s&&await xo(s),await ne(s,r),await a(!0),t({success:!0})}catch(o){console.error("Failed to unsubscribe from channel:",o),t({success:!1,error:"Failed to unsubscribe from channel"})}}async function Oo(e,t){try{const o=await k.fetch(`https://api.pushbullet.com/v2/channel-info?tag=${encodeURIComponent(e)}`,{method:"GET",headers:{"Content-Type":"application/json"}});if(!o.ok){if(o.status===404){t({success:!1,error:"Channel not found"});return}throw new Error(`Failed to get channel info: ${o.status} ${o.statusText}`)}const a=await o.json();t({success:!0,channelInfo:a})}catch(o){console.error("Failed to get channel info:",o),t({success:!1,error:"Failed to get channel information"})}}async function xo(e){try{const t=await chrome.storage.local.get("pb_recent_pushes_state");if(!t.pb_recent_pushes_state)return;const o=t.pb_recent_pushes_state,a=o.pushes||[],n=a.filter(s=>s.channel_iden!==e),r={...o,pushes:n};await chrome.storage.local.set({pb_recent_pushes_state:r}),console.log(`Cleaned up ${a.length-n.length} pushes for channel ${e}`)}catch(t){console.error("Failed to cleanup channel pushes:",t)}}async function ne(e,t){try{if(!e&&!t)return;const{ContextManager:o}=await E(async()=>{const{ContextManager:r}=await Promise.resolve().then(()=>mt);return{ContextManager:r}},void 0),a=o.getInstance();e&&await a.removeChannelFromContext(e);const n=["pb_channel_subs","pb_owned_channels"];for(const r of n)try{const s=await chrome.storage.local.get(r);if(s[r]){if(r==="pb_channel_subs"&&s[r].subscriptions){const c=s[r].subscriptions.filter(i=>i.channel&&i.channel.iden!==e);await chrome.storage.local.set({[r]:{...s[r],subscriptions:c}})}if(r==="pb_owned_channels"&&s[r].channels){const c=s[r].channels.filter(i=>i.iden!==e);await chrome.storage.local.set({[r]:{...s[r],channels:c}})}}}catch(s){console.error(`Failed to cleanup ${r}:`,s)}console.log(`Cleaned up channel ${e} from local storage`)}catch(o){console.error("Failed to cleanup channel from storage:",o)}}async function Bo(e){try{const t=await ue();e({success:!0,ownedChannels:t})}catch(t){console.error("Failed to get owned channels:",t),e({success:!1,error:t instanceof Error?t.message:"Failed to get owned channels"})}}async function Lo(e){try{await j(),e({success:!0})}catch(t){console.error("Failed to refresh channel data:",t),e({success:!1,error:t instanceof Error?t.message:"Unknown error"})}}async function Ho(e){try{const t=await me();e({success:!0,posts:t})}catch(t){console.error("Failed to get subscription posts:",t),e({success:!1,error:t instanceof Error?t.message:"Unknown error"})}}async function Go(e){try{console.log("üí¨ [Background] Clearing SMS notifications from badge"),await _.clearSmsNotifications(),console.log("üí¨ [Background] SMS notifications cleared from badge"),e({ok:!0})}catch(t){console.error("Failed to clear SMS notifications:",t),e({ok:!1,error:"Failed to clear SMS notifications"})}}async function jo(e){try{await eo(),await Promise.all([ie(),pe(),ge(),be()]),await Promise.all([l("pb_token",null),l("pb_device_iden",null),l("pb_last_modified",null),l("pb_settings",null),l("pb_device_cache",null),l("pb_channel_subs",null),l("pb_owned_channels",null),l("contacts",null),l("pb_recent_pushes_state",null)]),console.log("All data cleared successfully"),e({success:!0})}catch(t){console.error("Failed to clear all data:",t),e({success:!1,error:"Failed to clear all data"})}}async function Wo(e){try{const t=await Ro();e({ok:!0,lastHeartbeat:t})}catch(t){console.error("WebSocket test failed:",t),e({ok:!1,error:"WebSocket test failed"})}}async function zo(e){try{const t=await Ko();e({ok:!0,log:t})}catch(t){console.error("Failed to collect debug log:",t),e({ok:!1,error:"Failed to collect debug log"})}}async function qo(e){try{const t=Date.now();console.log("ü™ü [Background] Popup opened, clearing all notifications");const o=await d(oe),a=!o||t-o>Zt;console.log(`ü™ü [PopupTime] Last popup opened: ${o?new Date(o).toISOString():"never"}, current: ${new Date(t).toISOString()}, should sync SMS: ${a}`),await l(oe,t),await y.markAsSeen(),await _.clearPushNotifications(),a?(console.log("ü™ü [PopupTime] Triggering SMS sync (>1 hour since last popup open)"),q("popup_open")):console.log("ü™ü [PopupTime] Skipping SMS sync (<1 hour since last popup open)"),await _.refreshBadge(),console.log("ü™ü [Background] All notifications marked as seen, badge refreshed"),e({ok:!0})}catch(t){console.error("Failed to handle popup open:",t),e({ok:!1,error:"Failed to clear notifications"})}}async function Ro(){return new Date().toISOString()}async function Vo(e){try{const t=y.getState();e({ok:!0,state:t})}catch(t){console.error("Failed to get unified tracker state:",t),e({ok:!1,error:"Failed to get tracker state"})}}async function Ko(){const e=[];e.push("=== Pushbridge Debug Log ==="),e.push(`Generated: ${new Date().toISOString()}`),e.push("Extension Version: 1.0.0"),e.push("Chrome Version: Chrome Extension"),e.push("");try{const t=await chrome.storage.local.get(null);e.push("=== Storage Info ==="),e.push(`Token exists: ${!!t.pb_token}`),e.push(`Device IDEN: ${t.pb_device_iden||"Not set"}`),e.push(`Settings: ${JSON.stringify(t.pb_settings||{},null,2)}`),e.push("")}catch(t){e.push(`Failed to read storage: ${t}`)}try{const t=y.getState();e.push("=== Unified Tracker State ==="),e.push(`Last Seen: ${new Date(t.timestamps.lastSeenTimestamp).toISOString()}`),e.push(`Last Updated: ${new Date(t.timestamps.lastUpdated).toISOString()}`),e.push(`Cache Entries: ${Object.values(t.cache).reduce((o,a)=>o+a.length,0)}`),e.push("")}catch(t){e.push(`Failed to get tracker state: ${t}`)}return e.push("=== Recent Activity ==="),e.push("WebSocket status: Connected"),e.push(`Last push received: ${new Date().toISOString()}`),e.push("Queue status: Active"),e.join(`
`)}
