import{s as d,r as u,P as h,g as l,h as k,a as N,n as _,u as y,f as Ve,b as Ke,c as F,d as Ye,e as v,i as de,t as E,j as Qe,k as R,l as Je,m as z,o as Xe,p as Ze,q as et,v as tt,w as ot,x as nt,y as at,z as rt}from"./notificationBadge.js";const st="modulepreload",it=function(e){return"/"+e},X={},C=function(t,o,n){let a=Promise.resolve();if(o&&o.length>0){let i=function(w){return Promise.all(w.map(p=>Promise.resolve(p).then(m=>({status:"fulfilled",value:m}),m=>({status:"rejected",reason:m}))))};document.getElementsByTagName("link");const s=document.querySelector("meta[property=csp-nonce]"),c=s?.nonce||s?.getAttribute("nonce");a=i(o.map(w=>{if(w=it(w),w in X)return;X[w]=!0;const p=w.endsWith(".css"),m=p?'[rel="stylesheet"]':"";if(document.querySelector(`link[href="${w}"]${m}`))return;const f=document.createElement("link");if(f.rel=p?"stylesheet":st,p||(f.as="script"),f.crossOrigin="",f.href=w,c&&f.setAttribute("nonce",c),document.head.appendChild(f),p)return new Promise((M,qe)=>{f.addEventListener("load",M),f.addEventListener("error",()=>qe(new Error(`Unable to preload CSS for ${w}`)))})}))}function r(s){const c=new Event("vite:preloadError",{cancelable:!0});if(c.payload=s,window.dispatchEvent(c),!c.defaultPrevented)throw s}return a.then(s=>{for(const c of s||[])c.status==="rejected"&&r(c.reason);return t().catch(r)})};let A=null,B=null,D=0,O=0;const ct=6,ue=ct*60*60*1e3;async function q(e=!1){try{const t=await l("pb_token");if(!t)throw new Error("No access token available");let o;e||(o=await l("pb_subscriptions_cursor"));const n=new URLSearchParams;o&&n.append("cursor",o);const a=o?`https://api.pushbullet.com/v2/subscriptions?${n}`:"https://api.pushbullet.com/v2/subscriptions",r=await k.fetch(a,{method:"GET",headers:{"Access-Token":t,"Content-Type":"application/json"}});if(!r.ok)throw r.status===401?(await u(h.TokenRevoked,{message:"Token revoked during channel fetch",code:r.status}),new Error("Token is invalid or revoked")):new Error(`Failed to fetch subscriptions: ${r.status} ${r.statusText}`);const s=await r.json();return s.cursor?(await d("pb_subscriptions_cursor",s.cursor),await d("pb_subscriptions_has_more",!0)):(await d("pb_subscriptions_cursor",null),await d("pb_subscriptions_has_more",!1)),await lt(s.subscriptions),chrome.runtime.sendMessage({type:"pb:subsUpdated",payload:{subscriptions:s.subscriptions}}).catch(()=>{}),s.subscriptions}catch(t){throw console.error("Failed to fetch channel subscriptions:",t),await u(h.Unknown,{message:`Failed to fetch channel subscriptions: ${t instanceof Error?t.message:"Unknown error"}`}),t}}async function he(e=!1){try{const t=await l("pb_token");if(!t)throw new Error("No access token available");let o;e||(o=await l("pb_channels_cursor"));const n=new URLSearchParams;n.append("active_only","true"),o&&n.append("cursor",o);const a=o?`https://api.pushbullet.com/v2/channels?${n}`:"https://api.pushbullet.com/v2/channels?active_only=true",r=await k.fetch(a,{method:"GET",headers:{"Access-Token":t,"Content-Type":"application/json"}});if(!r.ok)throw r.status===401?(await u(h.TokenRevoked,{message:"Token revoked during owned channels fetch",code:r.status}),new Error("Token is invalid or revoked")):new Error(`Failed to fetch owned channels: ${r.status} ${r.statusText}`);const s=await r.json();return s.cursor?(await d("pb_channels_cursor",s.cursor),await d("pb_channels_has_more",!0)):(await d("pb_channels_cursor",null),await d("pb_channels_has_more",!1)),await dt(s.channels),chrome.runtime.sendMessage({type:"pb:ownedChannelsUpdated",payload:{channels:s.channels}}).catch(()=>{}),s.channels}catch(t){throw console.error("Failed to fetch owned channels:",t),await u(h.Unknown,{message:`Failed to fetch owned channels: ${t instanceof Error?t.message:"Unknown error"}`}),t}}async function fe(e=!1){const t=Date.now();return!e&&A&&t-D<ue?A:await q(e)}async function ge(e=!1){const t=Date.now();return!e&&B&&t-O<ue?B:await he(e)}async function lt(e){A=e,D=Date.now(),await d("pb_channel_subs",{subscriptions:e,lastFetched:D})}async function dt(e){B=e,O=Date.now(),await d("pb_owned_channels",{channels:e,lastFetched:O})}async function V(){try{console.log("Refreshing channel data (subscriptions and owned channels)..."),await Promise.all([q(),he()]),console.log("Channel data refresh completed")}catch(e){throw console.error("Failed to refresh channel data:",e),await u(h.Unknown,{message:`Failed to refresh channel data: ${e instanceof Error?e.message:"Unknown error"}`}),e}}async function pe(){try{const e=await l("pb_channel_subs");if(e&&e.subscriptions)return A=e.subscriptions,D=e.lastFetched,e.subscriptions}catch(e){console.error("Failed to load cached subscriptions:",e)}return[]}async function we(){try{const e=await l("pb_owned_channels");if(e&&e.channels)return B=e.channels,O=e.lastFetched,e.channels}catch(e){console.error("Failed to load cached owned channels:",e)}return[]}async function ut(){A=null,D=0,await d("pb_channel_subs",null),await d("pb_subscriptions_cursor",null),await d("pb_subscriptions_has_more",null)}async function me(){try{await Promise.all([pe(),we()]),console.log("Channel manager initialized")}catch(e){console.error("Failed to initialize channel manager:",e)}}async function ke(e=50){try{const{getPushHistory:t}=await C(async()=>{const{getPushHistory:r}=await Promise.resolve().then(()=>Et);return{getPushHistory:r}},void 0),[o,n]=await Promise.all([t(e*2),fe()]),a=new Set(n.filter(r=>r.channel&&r.channel.iden).map(r=>r.channel.iden));return o.pushes.filter(r=>r.channel_iden&&a.has(r.channel_iden)).sort((r,s)=>s.created-r.created).slice(0,e)}catch(t){throw console.error("Failed to get subscription posts:",t),await u(h.Unknown,{message:`Failed to get subscription posts: ${t instanceof Error?t.message:"Unknown error"}`}),t}}const $=Object.freeze(Object.defineProperty({__proto__:null,clearSubscriptionsCache:ut,fetchSubscriptions:q,getOwnedChannels:ge,getSubscriptionPosts:ke,getSubscriptions:fe,initializeChannelManager:me,loadCachedOwnedChannels:we,loadCachedSubscriptions:pe,refreshChannelData:V},Symbol.toStringTag,{value:"Module"})),ht=1440*60*1e3,b="mirror_";async function ft(e){try{if(console.log("üîî [MirrorManager] Handling mirror push:",{application_name:e.application_name,package_name:e.package_name,title:e.title}),e.application_name==="SMS"){await kt(e);return}const t=`${Date.now()}_${Math.random().toString(36).substr(2,9)}`,o={package_name:e.package_name,notification_id:e.notification_id,notification_tag:e.notification_tag,source_device_iden:e.source_device_iden,title:e.title,body:e.body,application_name:e.application_name,icon_url:e.icon_url,expiresAt:Date.now()+ht};await d(`${b}${t}`,o);const n={type:"basic",title:e.title,message:e.body,iconUrl:e.icon_url?e.icon_url:"icons/48.png",requireInteraction:!0,silent:!1};await chrome.notifications.create(t,n),console.log("üîî [MirrorManager] Adding mirror notification to badge"),await _.addPushNotifications(1),await y.markAsProcessed("mirror",e.notification_id,Date.now()),console.log("Chrome notification created:",t,"for app:",e.package_name)}catch(t){console.error("Failed to handle mirror push:",t),await u(h.Unknown,{message:"Failed to create notification from phone",code:t instanceof Error?void 0:500})}}async function gt(e){try{console.log("üóëÔ∏è [MirrorManager] Handling remote dismissal:",{package_name:e.package_name,notification_id:e.notification_id});const t=await pt(e);for(const[o]of t)await chrome.notifications.clear(o),await N(`${b}${o}`),console.log("üóëÔ∏è [MirrorManager] Removing mirror notification from badge"),await _.addPushNotifications(-1),console.log("Chrome notification cleared:",o,"for app:",e.package_name)}catch(t){console.error("Failed to handle remote dismissal:",t),await u(h.Unknown,{message:"Failed to clear notification from phone",code:t instanceof Error?void 0:500})}}async function ye(e){try{console.log("üë§ [MirrorManager] Handling user dismissal for:",e);const t=await l(`${b}${e}`);if(!t){console.log("No metadata found for notification:",e),await chrome.notifications.clear(e);return}const o=await l("pb_user_iden");if(!o){console.error("No user ID found for dismissal");return}await wt(t,o),await N(`${b}${e}`),console.log("üë§ [MirrorManager] Removing mirror notification from badge (user dismissal)"),await _.addPushNotifications(-1),console.log("User dismissal sent to phone for:",e)}catch(t){console.error("Failed to handle user dismissal:",t),await u(h.Unknown,{message:"Failed to dismiss notification on phone",code:t instanceof Error?void 0:500})}}async function pt(e){const t=[];try{const o=await chrome.storage.local.get(null);for(const[n,a]of Object.entries(o))if(n.startsWith(b)){const r=a;if(r.package_name===e.package_name&&r.notification_id===e.notification_id&&r.notification_tag===e.notification_tag){const s=n.replace(b,"");t.push([s,r])}}}catch(o){console.error("Failed to find matching mirrors:",o)}return t}async function wt(e,t){try{const o=await l("pb_token");if(!o)throw new Error("No token available");const n={type:"push",push:{type:"dismissal",package_name:e.package_name,notification_id:e.notification_id,notification_tag:e.notification_tag,source_user_iden:t}},a=await k.fetch("https://api.pushbullet.com/v2/ephemerals",{method:"POST",headers:{"Content-Type":"application/json","Access-Token":o},body:JSON.stringify(n)});if(!a.ok)throw new Error(`Dismissal API error: ${a.status} ${a.statusText}`);console.log("Dismissal ephemeral sent successfully")}catch(o){throw console.error("Failed to send dismissal ephemeral:",o),o}}async function _e(){try{const e=await chrome.storage.local.get(null),t=Date.now();for(const[o,n]of Object.entries(e))if(o.startsWith(b)){const a=n;if(a.expiresAt<t){await N(o);continue}const r=o.replace(b,""),s={type:"basic",title:a.title,message:a.body,iconUrl:a.icon_url?a.icon_url:"icons/48.png",requireInteraction:!0,silent:!1};await chrome.notifications.create(r,s),console.log("Reconstructed notification:",r)}}catch(e){console.error("Failed to reconstruct mirrors:",e)}}async function be(){try{console.log("üßπ [MirrorManager] Cleaning up expired mirrors");const e=await chrome.storage.local.get(null),t=Date.now();let o=0;for(const[n,a]of Object.entries(e))n.startsWith(b)&&a.expiresAt<t&&(await N(n),o++,console.log("Cleaned up expired mirror:",n));o>0&&(console.log(`üßπ [MirrorManager] Removed ${o} expired mirrors from badge`),await _.addPushNotifications(-o))}catch(e){console.error("Failed to cleanup expired mirrors:",e)}}async function mt(){const e=[];try{const t=await chrome.storage.local.get(null),o=Date.now();for(const[n,a]of Object.entries(t))if(n.startsWith(b)){const r=a;if(r.expiresAt<o)continue;const s=n.replace(b,"");e.push({id:s,meta:r})}}catch(t){console.error("Failed to get active mirrors:",t)}return e}async function kt(e){try{if(e.application_name!=="SMS")return;const t=e.conversation_iden||`${e.package_name}:${e.address}`||e.notification_id,o=e.timestamp,n=o?Ve(o):Date.now();if(console.log("üì± [MirrorManager] Processing SMS with timestamp conversion:",{rawTimestamp:o,rawTimestampISO:o?new Date(o*1e3).toISOString():"none",convertedTimestamp:n,convertedTimestampISO:new Date(n).toISOString(),conversationId:t}),!await y.shouldShowNotification({id:e.notification_id||`sms_${Date.now()}`,type:"sms",created:n,metadata:{conversationId:t,packageName:e.package_name,applicationName:e.application_name}})){console.log(`‚è≠Ô∏è [MirrorManager] Skipping SMS notification (too old): ${t}`);return}const r=`sms_${Date.now()}_${Math.random().toString(36).substr(2,9)}`;console.log("üì± [MirrorManager] Creating Chrome notification for SMS:",{title:e.title,body:e.body,chromeNotifId:r}),await chrome.notifications.create(r,{type:"basic",title:e.title,message:e.body,iconUrl:e.icon_url?e.icon_url:"icons/48.png",requireInteraction:!1,silent:!1});const s={id:e.notification_id||`incoming_${Date.now()}`,pb_guid:e.pb_guid||`incoming_${Date.now()}_${Math.random()}`,timestamp:n,inbound:!0,text:e.body||"",image_url:e.image_url,conversation_iden:t};await Ke(t,s,t),await y.markAsProcessed("sms",s.id,n),console.log("‚úÖ [MirrorManager] Incoming SMS processed:",t,"Chrome notif:",r)}catch(t){console.error("Failed to handle incoming SMS:",t),await u(h.Unknown,{message:"Failed to handle incoming SMS",code:t instanceof Error?void 0:500})}}const yt=300*1e3;async function I(e=!1){try{if(!e){const n=await l("pb_contact_cache");if(n&&Date.now()-n.lastFetched<yt)return console.log("Using cached contact list"),n.contacts}const t=await _t(e),o={contacts:t,lastFetched:Date.now(),cursor:await l("pb_contacts_cursor"),hasMore:await l("pb_contacts_has_more")||!1};return await d("pb_contact_cache",o),console.log("Contact list cached with",t.length,"contacts"),t}catch(t){if(t instanceof Error&&t.message.includes("No token available")){const n=await l("pb_contact_cache");return n?(console.log("No token available, returning cached contact list"),n.contacts):(console.log("No token available, returning empty contact list"),[])}console.error("Failed to get contacts:",t);const o=await l("pb_contact_cache");if(o)return console.log("Returning expired cache due to fetch error"),o.contacts;throw t}}async function _t(e=!1){const t=await l("pb_token");if(!t)throw new Error("No token available");let o;e||(o=await l("pb_contacts_cursor"));const n=new URLSearchParams;o&&n.append("cursor",o);const a=o?`https://api.pushbullet.com/v2/chats?${n}`:"https://api.pushbullet.com/v2/chats",r=await k.fetch(a,{method:"GET",headers:{"Access-Token":t,"Content-Type":"application/json"}});if(!r.ok)throw r.status===401?(await u(h.TokenRevoked,{message:"Token revoked while fetching contacts",code:r.status}),new Error("Token is invalid or revoked")):new Error(`Failed to fetch contacts: ${r.status} ${r.statusText}`);const s=await r.json();s.cursor?(await d("pb_contacts_cursor",s.cursor),await d("pb_contacts_has_more",!0)):(await d("pb_contacts_cursor",null),await d("pb_contacts_has_more",!1));const c=[];if(s.chats&&Array.isArray(s.chats)){for(const i of s.chats)if(i.active&&i.with&&i.with.type==="user"){const w={iden:i.with.iden,name:i.with.name,email:i.with.email,email_normalized:i.with.email_normalized,image_url:i.with.image_url,active:i.active,created:i.created,modified:i.modified};c.push(w)}}return console.log(`Fetched ${c.length} contacts from API`),c}async function bt(){try{await d("pb_contact_cache",null),await d("pb_contacts_cursor",null),await d("pb_contacts_has_more",null),console.log("Contact cache cleared")}catch(e){throw console.error("Failed to clear contact cache:",e),e}}async function vt(e){return(await I()).find(o=>o.iden===e)||null}const W="user_context",U="context_refresh_triggers";class T{constructor(){this.context=null,this.isRefreshing=!1,this.refreshPromise=null}static getInstance(){return T.instance||(T.instance=new T),T.instance}async getContext(t){if(t.type==="popup_open"?await this.refreshContext(t):(!this.context||!this.context.is_valid)&&await this.refreshContext(t),!this.context)throw new Error("Failed to load user context");return this.context}async isKnownSource(t,o){if(!this.context)return!1;if(t&&this.context.devices.has(t))return!0;if(o){for(const n of this.context.subscriptions.values())if(n.channel.iden===o)return!0}return!!(o&&this.context.owned_channels.has(o))}async handleUnknownSource(t,o){const n={type:"unknown_source",timestamp:Date.now(),reason:`Unknown source: device=${t}, channel=${o}`};await this.refreshContext(n)}async refreshContext(t){if(this.isRefreshing&&this.refreshPromise){await this.refreshPromise;return}this.isRefreshing=!0,this.refreshPromise=this.performRefresh(t);try{await this.refreshPromise}finally{this.isRefreshing=!1,this.refreshPromise=null}}async performRefresh(t){try{const o=await l("pb_token");if(!o)throw new Error("No token available");const n=await l("pb_device_iden");if(!n)throw new Error("Current device not registered");const[a,r,s,c]=await Promise.all([this.fetchSubscriptions(o),this.fetchChannels(o),this.fetchDevices(o),this.fetchContacts(o)]),i=new Map,w=new Map,p=new Map,m=new Map;r.channels&&Array.isArray(r.channels)&&r.channels.forEach(f=>{f&&f.iden?i.set(f.iden,f):console.warn("Skipping channel with missing iden:",f)}),a.subscriptions&&Array.isArray(a.subscriptions)&&a.subscriptions.forEach(f=>{f.channel&&f.channel.iden?w.set(f.channel.iden,f):console.warn("Skipping subscription with missing channel data:",f)}),s.devices&&Array.isArray(s.devices)&&s.devices.forEach(f=>{f&&f.iden?p.set(f.iden,f):console.warn("Skipping device with missing iden:",f)}),c&&Array.isArray(c)&&c.forEach(f=>{f&&f.iden?m.set(f.iden,f):console.warn("Skipping contact with missing iden:",f)}),this.context={current_device_iden:n,owned_channels:i,subscriptions:w,devices:p,contacts:m,last_refreshed:Date.now(),is_valid:!0},await this.saveContext(),await this.saveRefreshTrigger(t),console.log("Context refreshed successfully",{ownedChannels:i.size,subscriptions:w.size,devices:p.size,contacts:m.size,trigger:t.type})}catch(o){throw console.error("Failed to refresh context:",o),this.context&&(this.context.is_valid=!1,await this.saveContext()),await u(h.Unknown,{message:"Failed to refresh user context",code:o instanceof Error?void 0:500}),o}}async fetchSubscriptions(t){const o=await k.fetch("https://api.pushbullet.com/v2/subscriptions",{method:"GET",headers:{"Access-Token":t,"Content-Type":"application/json"}});if(!o.ok)throw o.status===401?(await u(h.TokenRevoked,{message:"Token revoked while fetching subscriptions",code:o.status}),new Error("Token is invalid or revoked")):new Error(`Failed to fetch subscriptions: ${o.status} ${o.statusText}`);const n=await o.json();if(!n||typeof n!="object")throw new Error("Invalid response format from subscriptions API");return(!n.subscriptions||!Array.isArray(n.subscriptions))&&(console.warn("Subscriptions API returned unexpected format, using empty array"),n.subscriptions=[]),n}async fetchChannels(t){const o=await k.fetch("https://api.pushbullet.com/v2/channels?limit=500&active_only=true",{method:"GET",headers:{"Access-Token":t,"Content-Type":"application/json"}});if(!o.ok)throw o.status===401?(await u(h.TokenRevoked,{message:"Token revoked while fetching channels",code:o.status}),new Error("Token is invalid or revoked")):new Error(`Failed to fetch channels: ${o.status} ${o.statusText}`);const n=await o.json();if(!n||typeof n!="object")throw new Error("Invalid response format from channels API");return(!n.channels||!Array.isArray(n.channels))&&(console.warn("Channels API returned unexpected format, using empty array"),n.channels=[]),n}async fetchDevices(t){const o=await k.fetch("https://api.pushbullet.com/v2/devices",{method:"GET",headers:{"Access-Token":t,"Content-Type":"application/json"}});if(!o.ok)throw o.status===401?(await u(h.TokenRevoked,{message:"Token revoked while fetching devices",code:o.status}),new Error("Token is invalid or revoked")):new Error(`Failed to fetch devices: ${o.status} ${o.statusText}`);const n=await o.json();if(!n||typeof n!="object")throw new Error("Invalid response format from devices API");return(!n.devices||!Array.isArray(n.devices))&&(console.warn("Devices API returned unexpected format, using empty array"),n.devices=[]),n}async fetchContacts(t){const o=await k.fetch("https://api.pushbullet.com/v2/chats",{method:"GET",headers:{"Access-Token":t,"Content-Type":"application/json"}});if(!o.ok)throw o.status===401?(await u(h.TokenRevoked,{message:"Token revoked while fetching contacts",code:o.status}),new Error("Token is invalid or revoked")):new Error(`Failed to fetch contacts: ${o.status} ${o.statusText}`);const n=await o.json(),a=[];if(n.chats&&Array.isArray(n.chats)){for(const r of n.chats)if(r.active&&r.with&&r.with.type==="user"){const s={iden:r.with.iden,name:r.with.name,email:r.with.email,email_normalized:r.with.email_normalized,image_url:r.with.image_url,active:r.active,created:r.created,modified:r.modified};a.push(s)}}return a}async saveContext(){if(this.context){const t={...this.context,owned_channels:Array.from(this.context.owned_channels.entries()),subscriptions:Array.from(this.context.subscriptions.entries()),devices:Array.from(this.context.devices.entries())};await d(W,t)}}async loadContext(){try{const t=await l(W);t&&(this.context={...t,owned_channels:new Map(t.owned_channels||[]),subscriptions:new Map(t.subscriptions||[]),devices:new Map(t.devices||[])})}catch(t){console.error("Failed to load context from storage:",t),this.context=null}}async saveRefreshTrigger(t){try{const o=await l(U),n=Array.isArray(o)?o:[];n.push(t),n.length>10&&n.splice(0,n.length-10),await d(U,n)}catch(o){console.error("Failed to save refresh trigger:",o)}}async getRefreshTriggers(){return await l(U)||[]}async clearContext(){this.context=null,await d(W,null),await d(U,null)}async removeChannelFromContext(t){!this.context||!this.context.subscriptions||(this.context.subscriptions.delete(t),await this.saveContext(),console.log(`Removed channel ${t} from user context`))}}const P=T.getInstance(),St=Object.freeze(Object.defineProperty({__proto__:null,ContextManager:T,contextManager:P},Symbol.toStringTag,{value:"Module"}));class Tt{static enrichPush(t,o){const n=this.computeMetadata(t,o);return{...t,metadata:n}}static enrichPushes(t,o){return t.map(n=>this.enrichPush(n,o))}static computeMetadata(t,o){const n=this.determineSourceType(t,o),a=this.determineOwnership(t,o),r=this.determineFileInfo(t),s=this.computeDisplaySource(t,o,n),c=this.computeOwnershipReason(t,o,a,n);return{source_type:n,source_channel_tag:this.getChannelTag(t,o),source_channel_name:this.getChannelName(t,o),source_device_nickname:this.getDeviceNickname(t,o),is_owned_by_user:a,can_delete:a,can_dismiss:!0,has_file:r,file_metadata:r?this.getFileMetadata(t):void 0,display_source:s,ownership_reason:c}}static determineSourceType(t,o){return t.channel_iden?o.owned_channels.has(t.channel_iden)?"channel_broadcast":(o.subscriptions.has(t.channel_iden),"channel_subscription"):"device"}static determineOwnership(t,o){return!!(t.source_device_iden===o.current_device_iden||t.channel_iden&&o.owned_channels.has(t.channel_iden))}static determineFileInfo(t){return!!(t.file_name||t.file_url||t.image_url)}static getFileMetadata(t){if(this.determineFileInfo(t))return{name:t.file_name||"Unknown file",type:t.file_type||"unknown",url:t.file_url||t.image_url}}static getChannelTag(t,o){if(!t.channel_iden)return;const n=o.owned_channels.get(t.channel_iden);if(n)return n.tag;const a=o.subscriptions.get(t.channel_iden);if(a)return a.channel.tag}static getChannelName(t,o){if(!t.channel_iden)return;const n=o.owned_channels.get(t.channel_iden);if(n)return n.name;const a=o.subscriptions.get(t.channel_iden);if(a)return a.channel.name}static getDeviceNickname(t,o){return t.source_device_iden?o.devices.get(t.source_device_iden)?.nickname:void 0}static computeDisplaySource(t,o,n){switch(n){case"device":{const a=this.getDeviceNickname(t,o);return t.source_device_iden===o.current_device_iden?"Your device":a||"Unknown device"}case"channel_broadcast":return`Channel: ${this.getChannelName(t,o)||"Unknown channel"}`;case"channel_subscription":return`Channel: ${this.getChannelName(t,o)||"Unknown channel"}`;default:return"Unknown source"}}static computeOwnershipReason(t,o,n,a){if(!n)return"You received this";switch(a){case"device":return t.source_device_iden===o.current_device_iden?"You sent this":"From your device";case"channel_broadcast":return`You own channel: ${this.getChannelName(t,o)||"Unknown channel"}`;case"channel_subscription":return"You received this from a channel";default:return"You own this"}}static async checkAndHandleUnknownSource(t){await P.isKnownSource(t.source_device_iden,t.channel_iden)||await P.handleUnknownSource(t.source_device_iden,t.channel_iden)}static async enrichPushesWithContextRefresh(t,o){for(const a of t)await this.checkAndHandleUnknownSource(a);const n=await P.getContext(o);return this.enrichPushes(t,n)}}async function x(e){try{if(!e.type||!["note","link","broadcast"].includes(e.type))throw new Error('Invalid push type. Must be "note", "link", or "broadcast"');if(e.type==="link"&&!e.url)throw new Error("URL is required for link pushes");if(e.type==="broadcast"&&!e.channel_tag)throw new Error("Channel tag is required for broadcast pushes");const t=await l("pb_token");if(!t)throw new Error("No token available");const o=await l("pb_device_iden");if(!o)throw new Error("Chrome device not registered");const n={type:e.type==="broadcast"?"note":e.type,source_device_iden:o};e.title&&(n.title=e.title),e.body&&(n.body=e.body),e.type==="link"&&(n.url=e.url),e.type==="broadcast"?n.channel_tag=e.channel_tag:e.targetDeviceIden?n.target_device_iden=e.targetDeviceIden:e.email&&(n.email=e.email);const a=await k.fetch("https://api.pushbullet.com/v2/pushes",{method:"POST",headers:{"Access-Token":t,"Content-Type":"application/json"},body:JSON.stringify(n)});if(!a.ok){if(a.status===401)throw await u(h.TokenRevoked,{message:"Token revoked while creating push",code:a.status}),new Error("Token is invalid or revoked");if(a.status===400){const s=await a.json();throw new Error(`Invalid push data: ${s.error?.message||"Bad request"}`)}throw new Error(`Failed to create push: ${a.status} ${a.statusText}`)}return await a.json()}catch(t){throw await u(h.Unknown,{message:"Failed to create push",code:t instanceof Error?void 0:500}),t}}async function K(e){try{if(e.size>26214400)throw new Error(`File size (${(e.size/1024/1024).toFixed(1)}MB) exceeds the 25MB limit`);const o=await l("pb_token");if(!o)throw new Error("No token available");const n={file_name:e.name,file_type:e.type||"application/octet-stream"},a=await k.fetch("https://api.pushbullet.com/v2/upload-request",{method:"POST",headers:{"Access-Token":o,"Content-Type":"application/json"},body:JSON.stringify(n)});if(!a.ok){if(a.status===401)throw await u(h.TokenRevoked,{message:"Token revoked while requesting upload",code:a.status}),new Error("Token is invalid or revoked");if(a.status===413)throw new Error("File too large for upload");if(a.status===400){const c=await a.json();throw new Error(`Invalid upload request: ${c.error?.message||"Bad request"}`)}throw new Error(`Failed to request upload: ${a.status} ${a.statusText}`)}const r=await a.json(),s={uploadUrl:r.upload_url,fileUrl:r.file_url,s3Fields:r.data};return console.log("Upload request successful:",s.fileUrl),s}catch(t){throw console.error("Failed to request upload:",t),await u(h.Unknown,{message:"Failed to request file upload",code:t instanceof Error?void 0:500}),t}}async function ve(e,t,o,n,a,r,s,c){try{const i=await l("pb_token");if(!i)throw new Error("No token available");const w=await l("pb_device_iden");if(!w)throw new Error("Chrome device not registered");const p={type:"file",file_name:t,file_type:o,file_url:e,source_device_iden:w};n&&(p.target_device_iden=n),c&&(p.email=c),a&&(p.title=a),r&&(p.body=r+" (File: "+t+")"),s&&(p.channel_tag=s);const m=await k.fetch("https://api.pushbullet.com/v2/pushes",{method:"POST",headers:{"Access-Token":i,"Content-Type":"application/json"},body:JSON.stringify(p)});if(!m.ok){if(m.status===401)throw await u(h.TokenRevoked,{message:"Token revoked while creating file push",code:m.status}),new Error("Token is invalid or revoked");if(m.status===400){const M=await m.json();throw new Error(`Invalid file push data: ${M.error?.message||"Bad request"}`)}throw new Error(`Failed to create file push: ${m.status} ${m.statusText}`)}const f=await m.json();return console.log("File push created successfully:",f.iden),f}catch(i){throw console.error("Failed to create file push:",i),await u(h.Unknown,{message:"Failed to create file push",code:i instanceof Error?void 0:500}),i}}async function L(e=200,t,o){try{const n=await l("pb_token");if(!n)throw new Error("No token available");const a=new URLSearchParams;a.append("limit",e.toString()),t&&a.append("modified_after",t.toString()),o&&a.append("cursor",o);const r=await k.fetch(`https://api.pushbullet.com/v2/pushes?${a}`,{method:"GET",headers:{"Access-Token":n,"Content-Type":"application/json"}});if(!r.ok)throw r.status===401?(await u(h.TokenRevoked,{message:"Token revoked while fetching push history",code:r.status}),new Error("Token is invalid or revoked")):new Error(`Failed to fetch push history: ${r.status} ${r.statusText}`);const s=await r.json();return{pushes:s.pushes,cursor:s.cursor}}catch(n){throw await u(h.Unknown,{message:"Failed to fetch push history",code:n instanceof Error?void 0:500}),n}}async function Y(e,t=200,o,n){try{const a=await l("pb_token");if(!a)throw new Error("No token available");const r=new URLSearchParams;r.append("limit",t.toString()),o&&r.append("modified_after",o.toString()),n&&r.append("cursor",n);const s=await k.fetch(`https://api.pushbullet.com/v2/pushes?${r}`,{method:"GET",headers:{"Access-Token":a,"Content-Type":"application/json"}});if(!s.ok)throw s.status===401?(await u(h.TokenRevoked,{message:"Token revoked while fetching push history",code:s.status}),new Error("Token is invalid or revoked")):new Error(`Failed to fetch push history: ${s.status} ${s.statusText}`);const c=await s.json();return{pushes:await Tt.enrichPushesWithContextRefresh(c.pushes,e),cursor:c.cursor}}catch(a){throw await u(h.Unknown,{message:"Failed to fetch enhanced push history",code:a instanceof Error?void 0:500}),a}}async function Q(e){const t=await l("pb_token");if(!t)throw new Error("No token available");const o=await k.fetch(`https://api.pushbullet.com/v2/pushes/${e}`,{method:"POST",headers:{"Access-Token":t,"Content-Type":"application/json"},body:JSON.stringify({dismissed:!0})});if(!o.ok)throw o.status===401?(await u(h.TokenRevoked,{message:"Token revoked while dismissing push",code:o.status}),new Error("Token is invalid or revoked")):new Error(`Failed to dismiss push: ${o.status} ${o.statusText}`)}async function Se(e){const t=await l("pb_token");if(!t)throw new Error("No token available");const o=await k.fetch(`https://api.pushbullet.com/v2/pushes/${e}`,{method:"DELETE",headers:{"Access-Token":t,"Content-Type":"application/json"}});if(!o.ok)throw o.status===401?(await u(h.TokenRevoked,{message:"Token revoked while deleting push",code:o.status}),new Error("Token is invalid or revoked")):new Error(`Failed to delete push: ${o.status} ${o.statusText}`)}const Et=Object.freeze(Object.defineProperty({__proto__:null,createFilePush:ve,createPush:x,deletePush:Se,dismissPush:Q,getEnhancedPushHistory:Y,getPushHistory:L,requestUpload:K},Symbol.toStringTag,{value:"Module"})),g={socket:null,isConnected:!1,lastHeartbeat:0,retryCount:0,reconnectTimer:null,isPolling:!1,pollInterval:null},Te=10,Z=[2e3,4e3,8e3,16e3,32e3],Ft=6e4,Ct=6e4;async function J(){try{if(!await l("pb_token")){console.log("No token available, skipping WebSocket initialization");return}await Ee()}catch(e){console.error("Failed to initialize WebSocket:",e),await u(h.Unknown,{message:"Failed to initialize WebSocket connection",code:e instanceof Error?void 0:500})}}async function Ee(){try{const e=await l("pb_token");if(!e)throw new Error("No token available");g.socket&&g.socket.close(),g.reconnectTimer&&(clearTimeout(g.reconnectTimer),g.reconnectTimer=null),g.pollInterval&&(clearInterval(g.pollInterval),g.pollInterval=null);const t=`wss://stream.pushbullet.com/websocket/${e}`;console.log("Connecting to WebSocket:",t),g.socket=new WebSocket(t),g.socket.onopen=Mt,g.socket.onmessage=Pt,g.socket.onclose=At,g.socket.onerror=Dt}catch(e){console.log("Failed to connect WebSocket:",e),await Fe()}}function Mt(){console.log("WebSocket connected"),g.isConnected=!0,g.lastHeartbeat=Date.now(),g.retryCount=0,g.isPolling=!1,g.pollInterval&&(clearInterval(g.pollInterval),g.pollInterval=null)}function Pt(e){try{const t=JSON.parse(e.data);switch(console.log("WebSocket message received:",t.type),g.lastHeartbeat=Date.now(),t.type){case"nop":console.log("WebSocket heartbeat received");break;case"tickle":t.subtype==="push"?(console.log("Push tickle received, syncing history"),Ce()):t.subtype==="device"?(console.log("Device tickle received, syncing history"),Nt()):t.subtype==="contact"&&(console.log("Contact tickle received, syncing contacts"),It());break;case"push":console.log("Push message received:",t.push?.type),Ut(t);break;default:console.log("Unknown WebSocket message type:",t.type)}}catch(t){console.error("Failed to parse WebSocket message:",t)}}async function At(e){console.log("WebSocket closed:",e.code,e.reason),g.isConnected=!1,g.socket=null,g.retryCount<Te?await Fe():(console.log("Max retry count reached, switching to polling mode"),await $t())}function Dt(e){console.log("WebSocket connection error:",e),g.isConnected=!1}async function Fe(){g.retryCount++;const e=Z[Math.min(g.retryCount-1,Z.length-1)];console.log(`WebSocket connection failed, retry ${g.retryCount}/${Te} in ${e}ms`),g.reconnectTimer=setTimeout(()=>{Ee()},e)}async function $t(){g.isPolling||(console.log("Switching to polling mode due to WebSocket connection failures"),g.isPolling=!0,await u(h.Unknown,{message:"Real-time connection lost; falling back to polling.",code:1001}),g.pollInterval=setInterval(()=>{Ce()},Ct))}async function Ce(){try{console.log("üîÑ [WebSocket] Push tickle received, syncing history with unified tracker");const e=await L(50,0,"");if(e.pushes&&e.pushes.length>0){console.log(`üîÑ [WebSocket] Found ${e.pushes.length} pushes to process`);let t=0,o=0;for(const n of e.pushes)!n.dismissed&&(n.receiver_iden||n.target_device_iden||n.type==="mirror"||n.type==="file"||n.type==="link"||n.channel_iden)&&(console.log(`üîî [WebSocket] Processing push: ${n.iden} (type: ${n.type}, created: ${n.created})`),await y.shouldShowNotification({id:n.iden,type:"push",created:n.created,metadata:{pushIden:n.iden}})?(console.log(`üÜï [WebSocket] New push detected: ${n.iden} (timestamp: ${n.created})`),n.type==="link"&&(console.log("üîó [WebSocket] Processing link push from history"),await Me(n)),await _.addPushNotifications(1),await y.markAsProcessed("push",n.iden,new Date(F(n.created)*1e3).getTime()),o++):console.log(`‚è≠Ô∏è [WebSocket] Skipping already processed push: ${n.iden}`),t++);console.log(`üîÑ [WebSocket] Processed ${t} pushes, ${o} new pushes from tickle`)}}catch(e){console.error("Failed to handle push tickle:",e)}}async function Nt(){try{console.log("üîÑ [WebSocket] Device tickle received, refreshing devices directly"),await Ye(!0),console.log("üîÑ [WebSocket] Devices refreshed successfully")}catch(e){console.error("Failed to handle device tickle:",e)}}async function It(){try{console.log("üîÑ [WebSocket] Contact tickle received, refreshing contacts directly"),await I(!0),console.log("üîÑ [WebSocket] Contacts refreshed successfully")}catch(e){console.error("Failed to handle contact tickle:",e)}}async function Ut(e){try{const t=e.push;if(!t||!t.type){console.log("Invalid push message format");return}switch(t.type){case"mirror":console.log("Mirror push received, creating Chrome notification"),await ft(t);break;case"dismissal":console.log("Dismissal push received, clearing Chrome notification"),await gt(t);break;case"sms_changed":console.log("SMS changed push received, triggering SMS sync"),await Bt(t);break;case"link":console.log("Link push received, opening in new tab"),await Me(t);break;default:console.log("Unhandled push type:",t.type)}}catch(t){console.error("Failed to handle push message:",t),await u(h.Unknown,{message:"Failed to process push message",code:t instanceof Error?void 0:500})}}async function Bt(e){try{console.log("üì± [WebSocket] SMS changed detected, triggering simple sync"),console.log("üì± [WebSocket] SMS changed push:",e);const t=await v();if(!t){console.warn("‚ö†Ô∏è [WebSocket] No SMS device for sync");return}await de(t.iden)}catch(t){console.error("üì± [WebSocket] Failed to handle SMS changed:",t)}}async function Me(e){try{if(console.log("üîó [WebSocket] Link push received:",e),!(await l("pb_settings"))?.autoOpenPushLinksAsTab){console.log("üîó [WebSocket] Auto-open links disabled, skipping tab creation");return}const o=e.url;if(!o){console.warn("‚ö†Ô∏è [WebSocket] Link push missing URL");return}try{new URL(o)}catch(n){console.warn("‚ö†Ô∏è [WebSocket] Invalid URL format:",o,n);return}console.log(`üîó [WebSocket] Opening URL in new tab: ${o}`),await chrome.tabs.create({url:o,active:!1}),console.log("‚úÖ [WebSocket] Successfully opened link in new tab")}catch(t){console.error("üîó [WebSocket] Failed to handle link push:",t),await u(h.Unknown,{message:"Failed to open link in new tab",code:t instanceof Error?void 0:500})}}function Pe(){return!g.isConnected||!g.socket?!1:Date.now()-g.lastHeartbeat<Ft}function Ae(){return{isConnected:g.isConnected,isPolling:g.isPolling,retryCount:g.retryCount,lastHeartbeat:g.lastHeartbeat}}const De="keepalive",$e="channel-refresh",Ne="token-bucket-refill",ee=5,te=6,oe=2;async function Ot(){try{await chrome.alarms.create(De,{periodInMinutes:ee}),console.log(`Keep-alive alarm created with ${ee} minute interval`),await chrome.alarms.create($e,{periodInMinutes:te*60}),console.log(`Channel refresh alarm created with ${te} hour interval`),await chrome.alarms.create(Ne,{periodInMinutes:oe}),console.log(`Token bucket refill alarm created with ${oe} minute interval`),chrome.alarms.onAlarm.addListener(xt)}catch(e){console.error("Failed to initialize alarms:",e)}}function xt(e){e.name===De?Lt():e.name===$e?Wt():e.name===Ne&&Ht()}async function Lt(){console.log("keepalive - checking system health");try{const e=Ae(),t=Pe();console.log("WebSocket status:",e),!t&&e.lastHeartbeat>0&&Date.now()-e.lastHeartbeat>6e4&&(console.log("WebSocket heartbeat stale, attempting reconnection"),await J()),await be(),console.log("üîÑ [Alarm] Refreshing notification badge"),await _.refreshBadge(),e.retryCount>0&&console.log(`WebSocket reconnection attempts: ${e.retryCount}`)}catch(e){console.log("Keep-alive check failed:",e)}}async function Ht(){console.log("token-bucket-refill - checking token bucket status");try{const e=E.getDetailedStatus();console.log("Token bucket status:",e);const t=E.checkAndRefill();console.log(t?"üîÑ [Alarm] Token bucket refilled via time-based mechanism":"‚ÑπÔ∏è [Alarm] Token bucket refill not needed at this time");const o=Date.now()-e.lastRefill,n=300*1e3;e.bucket===0&&o>n&&(console.log("üö® [Alarm] Emergency token bucket refill triggered"),E.forceTimeBasedRefill())}catch(e){console.error("Token bucket refill check failed:",e)}}async function Wt(){console.log("channel-refresh - refreshing channel data");try{await V(),console.log("Channel data refreshed successfully")}catch(e){console.error("Channel refresh failed:",e),await u(h.Unknown,{message:"Channel data refresh failed",code:e instanceof Error?void 0:500})}}async function Rt(e){try{let t;e.arrayBuffer&&typeof e.arrayBuffer=="function"?t=await e.arrayBuffer():t=await new Promise((a,r)=>{const s=new FileReader;s.onload=()=>a(s.result),s.onerror=()=>r(s.error),s.readAsArrayBuffer(e)});const o=await crypto.subtle.digest("SHA-256",t);return Array.from(new Uint8Array(o)).map(a=>a.toString(16).padStart(2,"0")).join("")}catch(t){return console.error("Failed to generate file hash:",t),`${Date.now()}-${e.size}-${e.name}`}}async function Ie(e,t,o,n=0){const a={fileHash:e,uploadInfo:t,offset:n,fileName:o.name,fileSize:o.size,fileType:o.type||"application/octet-stream",timestamp:Date.now(),attempts:0},r=await l("pb_pending_uploads")||[],s=r.findIndex(c=>c.fileHash===e);s>=0?r[s]=a:r.push(a),await d("pb_pending_uploads",r)}async function Ue(e){const o=(await l("pb_pending_uploads")||[]).filter(n=>n.fileHash!==e);await d("pb_pending_uploads",o)}async function Be(e,t,o,n=0){const a=await Rt(t);try{await Ie(a,e,t,n);const r=new FormData;if(Object.entries(e.s3Fields).forEach(([c,i])=>{r.append(c,i)}),n>0){const c=t.slice(n);r.append("file",c,t.name)}else r.append("file",t);const s=await fetch(e.uploadUrl,{method:"POST",body:r});if(s.ok)return console.log("File upload completed successfully"),await Ue(a),o&&o({loaded:t.size,total:t.size,percentage:100}),{success:!0};{const c=`Upload failed with status ${s.status}: ${s.statusText}`;return console.error(c),s.status===413?(await u(h.FileTooLarge,{message:"File too large for upload",code:413}),{success:!1,error:"File too large for upload"}):s.status===400?(await u(h.InvalidUpload,{message:"Invalid upload request",code:400}),{success:!1,error:"Invalid upload request"}):(await u(h.Unknown,{message:"File upload failed",code:s.status}),{success:!1,error:"Upload failed"})}}catch(r){return console.error("Failed to upload file:",r),r instanceof TypeError&&r.message.includes("fetch")?(await u(h.NetworkError,{message:"Network error during file upload",code:void 0}),{success:!1,error:"Network error during upload"}):(await u(h.Unknown,{message:"Failed to upload file",code:r instanceof Error?void 0:500}),{success:!1,error:"Upload failed"})}}async function Gt(){try{const e=await l("pb_pending_uploads")||[];let t=0;for(const o of e){if(Date.now()-o.timestamp>3600*1e3){console.log("Skipping old pending upload:",o.fileName);continue}if(o.attempts>=3){console.log("Skipping upload with too many attempts:",o.fileName);continue}try{console.log(`Resuming upload for ${o.fileName} from offset ${o.offset}`),await Ue(o.fileHash),t++}catch(n){console.error("Failed to resume upload:",n),o.attempts++;const a=new File([],o.fileName,{type:o.fileType});Object.defineProperty(a,"size",{value:o.fileSize}),await Ie(o.fileHash,o.uploadInfo,a,o.offset)}}return t}catch(e){return console.error("Failed to resume interrupted uploads:",e),0}}async function jt(){try{const e=await l("pb_pending_uploads")||[],t=Date.now()-3600*1e3,o=e.filter(n=>n.timestamp>t);o.length!==e.length&&(await d("pb_pending_uploads",o),console.log(`Cleaned up ${e.length-o.length} old pending uploads`))}catch(e){console.error("Failed to cleanup old pending uploads:",e)}}const S={isOnline:!0,isProcessing:!1,processingInterval:null},zt=5e3,ne=3;async function ae(e){try{const t={...e,id:Kt(),timestamp:Date.now(),retryCount:0},o=await l("pb_pending_ops")||[];o.push(t),await d("pb_pending_ops",o),console.log("Operation queued:",t.type,t.id),S.isOnline&&await Oe()}catch(t){console.error("Failed to enqueue operation:",t),await u(h.Unknown,{message:"Failed to queue operation",code:t instanceof Error?void 0:500})}}async function Oe(){if(!S.isProcessing){S.isProcessing=!0;try{const e=await l("pb_pending_ops")||[];if(e.length===0)return;console.log(`Processing ${e.length} queued operations`);for(const t of e)try{await qt(t);const o=e.filter(n=>n.id!==t.id);await d("pb_pending_ops",o),await new Promise(n=>setTimeout(n,zt))}catch(o){if(console.error("Failed to process operation:",t.id,o),t.retryCount++,t.retryCount>=ne){console.log("Operation exceeded max retries, removing from queue:",t.id);const n=e.filter(a=>a.id!==t.id);await d("pb_pending_ops",n),await u(h.Unknown,{message:`Operation failed after ${ne} retries: ${t.type}`,code:1002})}else{const n=e.map(a=>a.id===t.id?t:a);await d("pb_pending_ops",n)}}}catch(e){console.error("Failed to process queue:",e)}finally{S.isProcessing=!1}}}async function qt(e){switch(e.type){case"pushSend":await x(e.payload);break;case"smsSend":throw new Error("SMS sending not yet implemented");case"dismissal":throw new Error("Dismissal not yet implemented");default:throw new Error(`Unknown operation type: ${e.type}`)}}async function Vt(){return{pendingCount:(await l("pb_pending_ops")||[]).length,isOnline:S.isOnline,isProcessing:S.isProcessing}}async function xe(){await d("pb_pending_ops",[]),console.log("Operation queue cleared")}function Kt(){return`op_${Date.now()}_${Math.random().toString(36).substr(2,9)}`}function Yt(){S.processingInterval=setInterval(()=>{S.isProcessing||Oe()},5e3),console.log("Operation queue system initialized")}const Qt=4*1024*1024,re=12,Le="quota-check",G="pb_push_history",j="pb_transfers",Jt="pb_settings";async function Xt(){try{await chrome.alarms.create(Le,{periodInMinutes:re*60}),console.log(`Quota monitor initialized with ${re} hour interval`),chrome.alarms.onAlarm.addListener(Zt),await He()}catch(e){console.error("Failed to initialize quota monitor:",e)}}function Zt(e){e.name===Le&&He()}async function He(){try{const e=await Qe();console.log(`Storage quota check: ${e} bytes used`),e>Qt&&(console.log("Storage quota exceeded, purging old data..."),await eo(),await u(h.QuotaExceeded,{message:`Storage quota exceeded (${Math.round(e/1024/1024*100)/100} MB used)`,code:e}))}catch(e){console.error("Failed to check quota:",e)}}async function eo(){const e=Date.now(),t=e-2160*60*60*1e3,o=e-720*60*60*1e3;let n=0;try{const a=await l(G)||[],r=a.filter(p=>p.timestamp>t);r.length<a.length&&(await d(G,r),n+=a.length-r.length,console.log(`Purged ${a.length-r.length} old push history entries`));const s=await l(j)||[],c=s.filter(p=>p.timestamp>o);c.length<s.length&&(await d(j,c),n+=s.length-c.length,console.log(`Purged ${s.length-c.length} old transfer entries`));const w=(await to()).filter(p=>p.startsWith("mirror_"));for(const p of w){const m=await l(p);m&&m.timestamp&&m.timestamp<o&&(await N(p),n++)}console.log(`Quota purge completed: ${n} items removed`)}catch(a){throw console.error("Failed to purge old data:",a),a}}async function to(){return[G,j,Jt,"pb_token","pb_device_iden","pb_last_modified"]}const se=6,We="token-health-check";async function oo(){try{await chrome.alarms.create(We,{periodInMinutes:se*60}),console.log(`Token health monitor initialized with ${se} hour interval`),chrome.alarms.onAlarm.addListener(no),await Re()}catch(e){console.error("Failed to initialize token health monitor:",e)}}function no(e){e.name===We&&Re()}async function Re(){try{const e=await l("pb_token");if(!e)return console.log("No token found for health check"),{isValid:!1,lastChecked:Date.now(),error:"No token found"};console.log("Checking token health...");const t=await k.fetch("https://api.pushbullet.com/v2/users/me",{method:"GET",headers:{"Access-Token":e,"Content-Type":"application/json"}}),o={isValid:t.ok,lastChecked:Date.now()};if(t.ok){const n=await t.json();console.log("Token health check passed for user:",n.name),await d("pb_token_health",o)}else t.status===401?(console.error("Token health check failed: Token revoked"),o.error="Token revoked",await ao()):(console.error("Token health check failed:",t.status,t.statusText),o.error=`API error: ${t.status}`);return await d("pb_token_health",o),o}catch(e){console.error("Token health check error:",e);const t={isValid:!1,lastChecked:Date.now(),error:e instanceof Error?e.message:"Unknown error"};return await d("pb_token_health",t),t}}async function ao(){try{console.log("Handling token revocation..."),await u(h.TokenRevoked,{message:"Token has been revoked by Pushbullet",code:401}),await d("pb_token",""),await d("pb_device_iden",""),await chrome.action.setBadgeText({text:"AUTH"}),await chrome.action.setBadgeBackgroundColor({color:"#ef4444"}),console.log("Token revocation handled")}catch(e){console.error("Failed to handle token revocation:",e)}}console.log("Pushbridge background service worker started");const ie="pb_last_popup_opened",ro=36e5;async function so(){try{console.log("[Background] Initializing SMS sync...");const e=await v();e?(console.log(`[Background] Default SMS device: ${e.nickname} (${e.iden})`),console.log(`[Background] SMS-capable device found: ${e.nickname}`),setInterval(async()=>{await H("periodic")},360*60*1e3),console.log("[Background] SMS sync initialized with 6-hour interval")):console.log("[Background] No SMS-capable device found, skipping SMS sync")}catch(e){console.error("[Background] Failed to initialize SMS sync:",e)}}chrome.runtime.onInstalled.addListener(async()=>{console.log("Pushbridge extension installed");try{await k.initialize(),await R.loadState(),console.log("[Background] Rate limit manager initialized"),E.initialize(),console.log("[Background] Token bucket initialized"),setInterval(()=>{const t=R.getDebugInfo(),o=E.getDetailedStatus();(t.isBackoffActive||t.backoffState.isActive)&&console.log("[Background] Backoff debug info:",t),o.bucket<=10&&console.log("[Background] Token bucket status:",o)},1e4),setInterval(async()=>{try{await y.validateState()||console.warn("[Background] Unified notification tracker state validation failed")}catch(t){console.error("[Background] Failed to validate unified notification tracker state:",t)}},300*1e3),await Ot(),await Xt(),await oo(),Yt(),await me(),await so(),console.log("[Background] SMS sync using simple system"),await P.loadContext(),console.log("[Background] Context manager initialized"),await y.initialize(),await J(),await _e();const e=await Gt();e>0&&console.log(`Resumed ${e} interrupted uploads`),await jt(),await ze()}catch(e){console.error("Failed to initialize background services:",e)}});chrome.runtime.onStartup.addListener(async()=>{console.log("Pushbridge service worker started");try{await _e(),await be()}catch(e){console.error("Failed to handle service worker startup:",e)}});chrome.notifications.onClicked.addListener(async e=>{try{const t=await l(`notification_${e}`);if(!t){console.log("No notification data found for:",e);return}t.url?await chrome.tabs.create({url:t.url}):await chrome.action.openPopup(),await d(`notification_${e}`,null)}catch(t){console.error("Failed to handle notification click:",t)}});chrome.notifications.onButtonClicked.addListener(async(e,t)=>{try{const o=await l(`notification_${e}`);if(!o)return;t===0&&(await Q(o.pushIden),await chrome.notifications.clear(e),await d(`notification_${e}`,null))}catch(o){console.error("Failed to handle notification button click:",o)}});chrome.notifications.onClicked.addListener(async e=>{if(e.includes("-")&&e.length===36)await ye(e);else try{const o=await l(`notification_${e}`);if(!o){console.log("No notification data found for:",e);return}o.url?await chrome.tabs.create({url:o.url}):await chrome.action.openPopup(),await d(`notification_${e}`,null)}catch(o){console.error("Failed to handle notification click:",o)}});chrome.notifications.onClosed.addListener(async(e,t)=>{t&&e.includes("-")&&e.length===36&&await ye(e)});chrome.runtime.onMessage.addListener((e,t,o)=>{switch(console.log("üì® [Background] Received message:",e),e.cmd){case"verifyToken":io(e.token,o);break;case"getDevices":lo(e.forceRefresh,o);break;case"clearDeviceCache":uo(o);break;case"getContacts":ho(e.forceRefresh,o);break;case"clearContactCache":fo(o);break;case"createPush":go(e.payload,o);break;case"getPushHistory":po(e.limit,e.modifiedAfter,e.cursor,o);break;case"getEnhancedPushHistory":wo(e.trigger,e.limit,e.modifiedAfter,e.cursor,o);break;case"dismissPush":mo(e.pushIden,o);break;case"deletePush":ko(e.pushIden,o);break;case"syncHistory":yo(o);break;case"getQueueStatus":vo(o);break;case"clearQueue":So(o);break;case"getActiveMirrors":To(o);break;case"POPUP_OPEN":Qo(o);break;case"CLEAR_SMS_NOTIFICATIONS":qo(o);break;case"UPLOAD_FILE":Eo(e.payload,o);break;case"UPLOAD_FILE_FOR_SMS":Fo(e.payload,o);break;case"GET_TRANSFERS":Co(o);break;case"DOWNLOAD_FILE":Mo(e.payload,o);break;case"GET_SMS_CONVERSATIONS":case"GET_SMS_CONVERSATIONS_FROM_API":Po(o);break;case"GET_SMS_THREAD":case"GET_SMS_THREAD_FROM_API":case"LOAD_FULL_SMS_THREAD":ce(e.conversationId,e.deviceIden,o);break;case"GET_SMS_THREAD_PAGED":ce(e.conversationId,e.deviceIden,o);break;case"SEND_SMS":Oo(e.payload.conversationId,e.payload.message,o,e.payload.deviceIden,e.payload.attachments);break;case"MARK_CONVERSATION_READ":Ao(e.conversationId,o);break;case"GET_DEFAULT_SMS_DEVICE":Do(o);break;case"GET_SMS_CAPABLE_DEVICES":$o(o);break;case"SET_DEFAULT_SMS_DEVICE":No(e.deviceIden,o);break;case"SYNC_SMS_HISTORY":Io(e.deviceIden,o);break;case"RELOAD_SMS_THREAD":Uo(e.deviceIden,e.threadId,o);break;case"GET_SMS_DEVICE_INFO":Bo(o);break;case"GET_CHANNEL_SUBSCRIPTIONS":xo(e.forceRefresh,o);break;case"SUBSCRIBE_TO_CHANNEL":Lo(e.channelTag,o);break;case"UNSUBSCRIBE_FROM_CHANNEL":Ho(e.subscriptionIden,o);break;case"GET_CHANNEL_INFO":Wo(e.channelTag,o);break;case"GET_OWNED_CHANNELS":Go(o);break;case"REFRESH_CHANNEL_DATA":jo(o);break;case"GET_SUBSCRIPTION_POSTS":zo(o);break;case"clearAllData":Vo(o);break;case"testWebSocket":Ko(o);break;case"getDebugLog":Yo(o);break;case"getUnifiedTrackerState":Xo(o);break;case"DEBUG_SMS":case"DEBUG_STORAGE":o({success:!1,error:"Debug functions removed in simple system"});break;default:o({status:"unknown_command"})}return!0});async function io(e,t){try{E.forceRefill(100),console.log("üîë [Background] Token bucket initialized for verification");const o=await k.fetch("https://api.pushbullet.com/v2/users/me",{method:"GET",headers:{"Access-Token":e,"Content-Type":"application/json"}});if(o.ok){const n=await o.json();console.log("Token verified successfully for user:",n.name),await d("pb_token",e),await d("pb_user_iden",n.iden);try{const a=await Je();console.log("Chrome device registered:",a),console.log("üîÑ [Background] Fetching initial data after token verification..."),await co(),t({ok:!0,user:n,deviceIden:a})}catch(a){console.error("Device registration failed:",a),t({ok:!0,user:n,deviceError:"Device registration failed"})}}else o.status===401?(console.error("Token verification failed: Unauthorized"),await u(h.TokenRevoked,{message:"Token is invalid or revoked",code:o.status}),t({ok:!1,error:"Invalid token. Please check your Pushbullet access token."})):(console.error("Token verification failed:",o.status,o.statusText),await u(h.Unknown,{message:"Token verification failed",code:o.status}),t({ok:!1,error:"Token verification failed. Please try again."}))}catch(o){console.error("Token verification error:",o),await u(h.Unknown,{message:"Token verification failed"}),t({ok:!1,error:"Failed to verify token. Please check your internet connection."})}}async function co(){try{console.log("üîÑ [Background] Starting initial data fetch...");const e=[z(!0).then(()=>{console.log("‚úÖ [Background] Devices fetched successfully")}).catch(t=>{console.error("‚ùå [Background] Failed to fetch devices:",t)}),I(!0).then(()=>{console.log("‚úÖ [Background] Contacts fetched successfully")}).catch(t=>{console.error("‚ùå [Background] Failed to fetch contacts:",t)}),(async()=>{try{const{getSubscriptions:t}=await C(async()=>{const{getSubscriptions:o}=await Promise.resolve().then(()=>$);return{getSubscriptions:o}},void 0);await t(!0),console.log("‚úÖ [Background] Channel subscriptions fetched successfully")}catch(t){console.error("‚ùå [Background] Failed to fetch channel subscriptions:",t)}})(),(async()=>{try{const t=await Y({type:"manual",timestamp:Date.now(),reason:"token_verification"},50,0,void 0);console.log(`‚úÖ [Background] Recent pushes fetched successfully (${t.pushes.length} pushes)`)}catch(t){console.error("‚ùå [Background] Failed to fetch recent pushes:",t)}})(),(async()=>{try{await Xe()?(await H("token_verification"),console.log("‚úÖ [Background] SMS sync triggered successfully")):console.log("‚ÑπÔ∏è [Background] No SMS-capable devices found, skipping SMS sync")}catch(t){console.error("‚ùå [Background] Failed to trigger SMS sync:",t)}})(),(async()=>{try{await ze(),console.log("‚úÖ [Background] Context menus created successfully")}catch(t){console.error("‚ùå [Background] Failed to create context menus:",t)}})(),(async()=>{try{await J(),console.log("‚úÖ [Background] WebSocket connection ensured")}catch(t){console.error("‚ùå [Background] Failed to ensure WebSocket connection:",t)}})()];await Promise.allSettled(e),console.log("üéâ [Background] Initial data fetch completed")}catch(e){console.error("‚ùå [Background] Error during initial data fetch:",e)}}async function lo(e,t){try{const o=await z(e);t({ok:!0,devices:o})}catch(o){console.error("Failed to get devices:",o),t({ok:!1,error:"Failed to fetch devices"})}}async function uo(e){try{await Ze(),e({ok:!0})}catch(t){console.error("Failed to clear device cache:",t),e({ok:!1,error:"Failed to clear cache"})}}async function ho(e,t){try{const o=await I(e);t({ok:!0,contacts:o})}catch(o){console.error("Failed to get contacts:",o),t({ok:!1,error:"Failed to fetch contacts"})}}async function fo(e){try{await bt(),e({ok:!0})}catch(t){console.error("Failed to clear contact cache:",t),e({ok:!1,error:"Failed to clear contact cache"})}}async function go(e,t){try{if(!Pe()){await ae({type:"pushSend",payload:e}),t({ok:!0,queued:!0,message:"Push queued for later delivery"});return}const o=await x(e);try{chrome.runtime.sendMessage({cmd:"pushCreated",source:"background",push:o})}catch{}t({ok:!0,push:o})}catch(o){if(console.error("Failed to create push:",o),o instanceof Error&&o.message.includes("network")){await ae({type:"pushSend",payload:e}),t({ok:!0,queued:!0,message:"Push queued due to network error"});return}t({ok:!1,error:o instanceof Error?o.message:"Failed to create push"})}}async function po(e,t,o,n){try{const a=await L(e,t,o);if(console.log("üìã [handleGetPushHistory] Response:",{ok:!0,history:a.pushes.length,modifiedAfter:t,cursor:o}),a.pushes.length>0){const r=Math.max(...a.pushes.map(s=>s.modified));await d("pb_last_modified",r)}n({ok:!0,history:a})}catch(a){console.error("Failed to get push history:",a),n({ok:!1,error:"Failed to fetch push history"})}}async function wo(e,t,o,n,a){try{console.log("üîÑ [Background] Getting enhanced push history with trigger:",e.type);const r=await Y(e,t,o,n);if(console.log("üìã [handleGetEnhancedPushHistory] Response:",{ok:!0,history:r.pushes.length,modifiedAfter:o,cursor:n,trigger:e.type}),r.pushes.length>0){const s=Math.max(...r.pushes.map(c=>c.modified));if(await d("pb_last_modified",s),console.log("üîç [Background] Enhanced push details:",r.pushes.map(c=>({iden:c.iden,type:c.type,title:c.title,receiver_iden:c.receiver_iden,target_device_iden:c.target_device_iden,dismissed:c.dismissed,created:c.created,modified:c.modified,channel_iden:c.channel_iden}))),e.type==="unknown_source"){console.log("üîî [Background] Processing pushes for notifications (WebSocket tickle)");let c=0;for(const i of r.pushes)!i.dismissed&&(i.receiver_iden||i.target_device_iden||i.type==="mirror"||i.type==="file"||i.channel_iden)?await y.shouldShowNotification({id:i.iden,type:"push",created:i.created,metadata:{pushIden:i.iden}})?(console.log(`üîî [Background] Processing new push: ${i.iden} (type: ${i.type})`),(await Ge(i)||i.type==="file"||i.channel_iden)&&(console.log("üîî [Background] Updating badge for new push notification"),await _.addPushNotifications(1),await y.markAsProcessed("push",i.iden,new Date(F(i.created)*1e3).getTime()),c++)):console.log(`‚è≠Ô∏è [Background] Skipping already processed push: ${i.iden}`):console.log(`‚è≠Ô∏è [Background] Skipping push: ${i.iden} (dismissed: ${i.dismissed})`);console.log(`üìä [Background] New push processing summary: ${c} new notifications`)}else console.log(`‚è≠Ô∏è [Background] Skipping notification processing for trigger: ${e.type} (popup open)`)}else console.log("üîÑ [Background] No new pushes found in enhanced history");a({ok:!0,history:r})}catch(r){console.error("Failed to get enhanced push history:",r),a({ok:!1,error:"Failed to fetch enhanced push history"})}}async function mo(e,t){try{await Q(e),console.log("üîî [Background] Push dismissed, updating badge"),await _.addPushNotifications(-1),t({ok:!0})}catch(o){console.error("Failed to dismiss push:",o),t({ok:!1,error:"Failed to dismiss push"})}}async function ko(e,t){try{await Se(e),console.log("üîî [Background] Push deleted, updating badge"),await _.addPushNotifications(-1),t({ok:!0})}catch(o){console.error("Failed to delete push:",o),t({ok:!1,error:"Failed to delete push"})}}async function yo(e){try{console.log("üîÑ [Background] Syncing push history");const t=await l("pb_last_modified"),o=await chrome.storage.local.get("pb_recent_pushes_state"),n=o.pb_recent_pushes_state?.cursor,a=await L(100,t,n);if(a.pushes.length>0){console.log(`üîÑ [Background] Found ${a.pushes.length} pushes from API`),console.log("üîç [Background] Push details:",a.pushes.map(i=>({iden:i.iden,type:i.type,title:i.title,receiver_iden:i.receiver_iden,target_device_iden:i.target_device_iden,dismissed:i.dismissed,created:i.created,modified:i.modified})));const r=Math.max(...a.pushes.map(i=>i.modified));if(await d("pb_last_modified",r),a.cursor){const i=o.pb_recent_pushes_state||{};await chrome.storage.local.set({pb_recent_pushes_state:{...i,cursor:a.cursor,hasMore:!!a.cursor}})}let s=0,c=0;for(const i of a.pushes)!i.dismissed&&(i.receiver_iden||i.target_device_iden||i.type==="mirror"||i.type==="file"||i.channel_iden)?await y.shouldShowNotification({id:i.iden,type:"push",created:i.created,metadata:{pushIden:i.iden}})?(console.log(`üîî [Background] Processing push: ${i.iden} (type: ${i.type})`),(await Ge(i)||i.type==="file"||i.channel_iden)&&(console.log("üîî [Background] Updating badge for new push notification"),await _.addPushNotifications(1),await y.markAsProcessed("push",i.iden,new Date(F(i.created)*1e3).getTime())),s++):(console.log(`‚è≠Ô∏è [Background] Skipping already processed push: ${i.iden}`),c++):(console.log(`‚è≠Ô∏è [Background] Skipping push: ${i.iden} (dismissed: ${i.dismissed}, receiver_iden: ${i.receiver_iden}, target_device_iden: ${i.target_device_iden})`),c++);console.log(`üìä [Background] Push processing summary: ${s} processed, ${c} skipped`)}else console.log("üîÑ [Background] No new pushes found");try{chrome.runtime.sendMessage({cmd:"syncHistory",source:"background",newPushes:a.pushes.length})}catch{}e({ok:!0,newPushes:a.pushes.length})}catch(t){console.error("Failed to sync history:",t),e({ok:!1,error:"Failed to sync history"})}}async function Ge(e){try{console.log("üîî [Background] Showing push notification:",{type:e.type,title:e.title,channel_tag:e.channel_tag});const t=await l("pb_device_iden");if(e.receiver_iden!==t)return console.log("üîî [Background] Push not for this device, skipping notification"),!1;let o,n,a;if(e.type==="file"){o="File received",n=e.file_name||"New file",a="/icons/48.png";const s={id:e.iden,type:"received",fileName:e.file_name,fileSize:0,fileType:e.file_type||"application/octet-stream",timestamp:Date.now(),status:"completed",sourceDevice:e.source_device_iden};await je(s),await _o(e)}else e.channel_tag?(o=`${e.channel_tag}: ${e.title??"New post"}`,n=e.body??"",a="/icons/48.png",await bo(e)):(o=e.title||(e.type==="link"?e.url:"New push"),n=e.body||"",a="/icons/48.png");const r=`push_${e.iden}`;return await chrome.notifications.create(r,{type:"basic",iconUrl:a,title:o,message:n,requireInteraction:!0}),await d(`notification_${r}`,{pushIden:e.iden,url:e.url,type:e.type,channelTag:e.channel_tag}),console.log("üîî [Background] Updating badge for new push notification"),await _.addPushNotifications(1),console.log("üîî [Background] Push notification created:",r),!0}catch(t){return console.error("Failed to show push notification:",t),!1}}async function _o(e){try{await chrome.downloads.download({url:e.file_url,filename:e.file_name}),await chrome.notifications.create({type:"basic",iconUrl:"/icons/48.png",title:"File Downloaded",message:`File "${e.file_name}" has been downloaded`})}catch(t){console.error("Failed to download received file:",t),await chrome.notifications.create({type:"basic",iconUrl:"/icons/48.png",title:"File Available",message:`Click to view file "${e.file_name}"`})}}async function bo(e){try{const t=await l("pb_recent_pushes")||[],o={...e,isChannelPush:!0,channelTag:e.channel_tag};t.unshift(o),t.length>500&&t.splice(500),await d("pb_recent_pushes",t)}catch(t){console.error("Failed to add channel push to recent list:",t)}}async function vo(e){try{const t=await Vt(),o=Ae();e({ok:!0,queue:t,connection:o})}catch(t){console.error("Failed to get queue status:",t),e({ok:!1,error:"Failed to get queue status"})}}async function So(e){try{await xe(),e({ok:!0})}catch(t){console.error("Failed to clear queue:",t),e({ok:!1,error:"Failed to clear queue"})}}async function To(e){try{const t=await mt();e({success:!0,mirrors:t})}catch(t){console.error("Failed to get active mirrors:",t),e({success:!1,error:"Failed to fetch notifications"})}}async function je(e){try{const t=await l("pb_transfers")||[];t.unshift(e),t.length>50&&t.splice(50),await d("pb_transfers",t)}catch(t){console.error("Failed to add transfer record:",t)}}async function Eo(e,t){try{const{fileData:o,targetDeviceIden:n,email:a,title:r,body:s,channel_tag:c}=e,i=new File([new Uint8Array(o.buffer)],o.name,{type:o.type,lastModified:o.lastModified}),w=await K(i),m=await Be(w,i,f=>{chrome.runtime.sendMessage({type:"UPLOAD_PROGRESS",payload:{progress:f.percentage}}).catch(()=>{})});if(m.success){const f=await ve(w.fileUrl,i.name,i.type||"application/octet-stream",n,r,s,c,a),M={id:f.iden,type:"sent",fileName:i.name,fileSize:i.size,fileType:i.type||"application/octet-stream",timestamp:Date.now(),status:"completed",targetDevice:n};await je(M);try{chrome.runtime.sendMessage({cmd:"pushCreated",source:"background",push:f})}catch{}await chrome.notifications.create({type:"basic",iconUrl:"/icons/48.png",title:"File Sent",message:`File "${i.name}" sent successfully`}),t({success:!0,filePush:f})}else t({success:!1,error:m.error})}catch(o){console.error("Failed to upload file:",o),t({success:!1,error:o instanceof Error?o.message:"Upload failed"})}}async function Fo(e,t){try{const{fileData:o}=e,n=new File([new Uint8Array(o.buffer)],o.name,{type:o.type,lastModified:o.lastModified}),a=await K(n),s=await Be(a,n,c=>{chrome.runtime.sendMessage({type:"UPLOAD_PROGRESS",payload:{progress:c.percentage}}).catch(()=>{})});s.success?t({success:!0,fileUrl:a.fileUrl}):t({success:!1,error:s.error})}catch(o){console.error("Failed to upload file for SMS:",o),t({success:!1,error:o instanceof Error?o.message:"Upload failed"})}}async function Co(e){try{const t=await l("pb_transfers")||[];e({success:!0,transfers:t})}catch(t){console.error("Failed to get transfers:",t),e({success:!1,error:"Failed to load transfers"})}}async function Mo(e,t){try{if(!(await l("pb_transfers")||[]).find(a=>a.id===e.transferId)){t({success:!1,error:"Transfer not found"});return}await chrome.notifications.create({type:"basic",iconUrl:"/icons/48.png",title:"Download Not Available",message:"File download will be implemented in a future update"}),t({success:!0})}catch(o){console.error("Failed to download file:",o),t({success:!1,error:"Download failed"})}}async function ze(){chrome.contextMenus.removeAll(async()=>{try{const e=await z(),t=await I(),o=[{id:"push-page",title:"Push this page",contexts:["page"]},{id:"push-link",title:"Push this link",contexts:["link"]},{id:"push-image",title:"Push this image",contexts:["image"]},{id:"push-selection",title:"Push selected text",contexts:["selection"]}];for(const n of o){if(chrome.contextMenus.create({id:n.id,title:n.title,contexts:n.contexts}),e.length>0){chrome.contextMenus.create({id:`${n.id}-devices`,title:"Devices",parentId:n.id,contexts:n.contexts});for(const a of e)chrome.contextMenus.create({id:`${n.id}-device-${a.iden}`,title:`üì± ${a.nickname||"Unknown Device"}`,parentId:`${n.id}-devices`,contexts:n.contexts})}if(t.length>0){chrome.contextMenus.create({id:`${n.id}-contacts`,title:"Contacts",parentId:n.id,contexts:n.contexts});for(const a of t)chrome.contextMenus.create({id:`${n.id}-contact-${a.iden}`,title:`üë§ ${a.name}`,parentId:`${n.id}-contacts`,contexts:n.contexts})}chrome.contextMenus.create({id:`${n.id}-all`,title:"üì§ All Devices",parentId:n.id,contexts:n.contexts})}}catch(e){e instanceof Error&&e.message.includes("No token available")?console.log("No token available, skipping detailed context menu creation"):console.error("Failed to create context menus:",e),chrome.contextMenus.create({id:"push-page-all",title:"Push this page",contexts:["page"]})}})}chrome.contextMenus.onClicked.addListener(async(e,t)=>{if(console.log("üîÑ [Background] Context menu clicked:",e,t),!!t){console.log("üîÑ [Background] Context menu processing:",e,t);try{const o=e.menuItemId;let n,a;if(o.startsWith("push-page"))a="push-page",n={type:"link",url:t.url,title:t.title,body:`Page shared from ${new URL(t.url).hostname}`};else if(o.startsWith("push-link"))a="push-link",n={type:"link",url:e.linkUrl,title:e.linkText||e.linkUrl,body:`Link shared from ${new URL(t.url).hostname}`};else if(o.startsWith("push-image"))a="push-image",n={type:"link",url:e.srcUrl,title:e.altText||"Image",body:`Image shared from ${new URL(t.url).hostname}`};else if(o.startsWith("push-selection"))a="push-selection",n={type:"note",body:e.selectionText,title:`Text from ${new URL(t.url).hostname}`};else{console.warn("üîÑ [Background] Unknown context menu ID:",o);return}if(o.endsWith("-all"))console.log("üîÑ [Background] Sending to all devices");else if(o.includes("-device-")){const r=o.match(new RegExp(`${a}-device-(.+)`));if(r&&r[1]){const s=r[1];n.targetDeviceIden=s,console.log("üîÑ [Background] Sending to device:",s)}else{console.error("üîÑ [Background] Failed to extract device ID from menu ID:",o);return}}else if(o.includes("-contact-")){const r=o.match(new RegExp(`${a}-contact-(.+)`));if(r&&r[1]){const s=r[1],c=await vt(s);if(c)n.email=c.email,console.log("üîÑ [Background] Sending to contact:",c.email);else{console.error("üîÑ [Background] Contact not found for ID:",s);return}}else{console.error("üîÑ [Background] Failed to extract contact ID from menu ID:",o);return}}else console.log("üîÑ [Background] Parent menu clicked, sending to all devices");await x(n),await chrome.notifications.create({type:"basic",iconUrl:"/icons/48.png",title:"Push Sent",message:"Your push has been sent successfully!"})}catch(o){console.error("‚ùå [Background] Failed to handle context menu click:",o),await chrome.notifications.create({type:"basic",iconUrl:"/icons/48.png",title:"Push Failed",message:"Failed to send push. Please try again."})}}});async function Po(e){try{console.log("üì± [Background] Getting SMS conversations (simple) - returning cached data");const t=await v();if(!t){e({success:!1,error:"No SMS device available"});return}const o=await et(t.iden);e({success:!0,conversations:o.threads,lastSync:o.lastSync})}catch(t){console.error("[Background] Failed to get SMS conversations:",t),e({success:!1,error:t instanceof Error?t.message:"Failed to get conversations"})}}async function ce(e,t,o){try{console.log(`üì® [Background] Getting SMS thread: ${e} (simple)`);let n=t;if(!n){const r=await v();if(!r){o({success:!1,error:"No SMS device available"});return}n=r.iden}console.log("üì® [Background] Loading thread from cache (no sync needed)");const a=await tt(n,e);o(a?{success:!0,thread:a}:{success:!1,error:"Thread not found"})}catch(n){console.error("[Background] Failed to get SMS thread:",n),o({success:!1,error:n instanceof Error?n.message:"Failed to get thread"})}}async function H(e="manual"){try{console.log(`üîÑ [Background] Triggering SMS sync (${e})`);const t=await v();if(!t){console.warn("‚ö†Ô∏è [Background] No SMS device for sync");return}await de(t.iden)}catch(t){console.error(`‚ùå [Background] SMS sync failed (${e}):`,t)}}async function Ao(e,t){try{console.log(`[Background] Marking conversation ${e} as read`),t({success:!0})}catch(o){console.error("Failed to mark conversation as read:",o),t({success:!1,error:"Failed to mark as read"})}}async function Do(e){try{console.log("[Background] Getting default SMS device...");const t=await v();t?(console.log("[Background] Default SMS device found:",{iden:t.iden,nickname:t.nickname,has_sms:t.has_sms}),e({success:!0,device:{iden:t.iden,nickname:t.nickname,has_sms:t.has_sms}})):(console.warn("[Background] No SMS-capable device found"),e({success:!1,error:"No SMS-capable device found"}))}catch(t){console.error("[Background] Failed to get default SMS device:",t),e({success:!1,error:"Failed to get SMS device"})}}async function $o(e){try{const t=await ot();e({success:!0,devices:t})}catch(t){console.error("Failed to get SMS-capable devices:",t),e({success:!1,error:"Failed to get devices"})}}async function No(e,t){try{const o=await nt(e);t({success:o})}catch(o){console.error("Failed to set default SMS device:",o),t({success:!1,error:"Failed to set device"})}}async function Io(e,t){try{await H("manual"),t({success:!0})}catch(o){console.error("Failed to sync SMS history:",o),t({success:!1,error:"Failed to sync history"})}}async function Uo(e,t,o){try{if(console.log(`üì± [Background] Reloading SMS thread: ${t} for device: ${e}`),!e){const a=await v();if(!a){o({success:!1,error:"No SMS device available"});return}e=a.iden}if(!t){o({success:!1,error:"Thread ID is required"});return}const n=await at(e,t);o(n?{success:!0,thread:n}:{success:!1,error:"Failed to reload thread - device may be offline or thread not found"})}catch(n){console.error("[Background] Failed to reload SMS thread:",n),o({success:!1,error:n instanceof Error?n.message:"Failed to reload SMS thread"})}}async function Bo(e){try{const t=await v();e(t?{success:!0,device:{iden:t.iden,nickname:t.nickname,model:t.model,type:t.type}}:{success:!1,error:"No SMS device found"})}catch(t){console.error("Failed to get SMS device info:",t),e({success:!1,error:"Failed to get device info"})}}async function Oo(e,t,o,n,a){try{console.log("üì± [Background] Sending SMS:",{conversationId:e,messageLength:t.length,deviceIden:n,hasAttachments:!!a});let r=n;if(!r){const s=await v();if(!s){o({success:!1,error:"No SMS device available"});return}r=s.iden}if(!t.trim()&&(!a||a.length===0)){o({success:!1,error:"Message cannot be empty"});return}await rt(r,e,t,a),console.log("üì± [Background] SMS sent successfully to:",e),o({success:!0})}catch(r){console.error("üì± [Background] Failed to send SMS:",r),r instanceof Error?r.message.includes("Token is invalid or revoked")?o({success:!1,error:"Token is invalid or revoked"}):r.message.includes("Message cannot be empty")?o({success:!1,error:"Message cannot be empty"}):o({success:!1,error:r.message}):o({success:!1,error:"Failed to send SMS"})}}async function xo(e,t){try{const{getSubscriptions:o}=await C(async()=>{const{getSubscriptions:a}=await Promise.resolve().then(()=>$);return{getSubscriptions:a}},void 0),n=await o(e);t({success:!0,subscriptions:n})}catch(o){console.error("Failed to get channel subscriptions:",o),t({success:!1,error:"Failed to fetch channel subscriptions"})}}async function Lo(e,t){try{const o=await l("pb_token");if(!o){t({success:!1,error:"No access token available"});return}const n=await k.fetch("https://api.pushbullet.com/v2/subscriptions",{method:"POST",headers:{"Access-Token":o,"Content-Type":"application/json"},body:JSON.stringify({channel_tag:e})});if(!n.ok){if(n.status===401){await u(h.TokenRevoked,{message:"Token revoked during channel subscription",code:n.status}),t({success:!1,error:"Token is invalid or revoked"});return}throw new Error(`Failed to subscribe: ${n.status} ${n.statusText}`)}const a=await n.json(),{getSubscriptions:r}=await C(async()=>{const{getSubscriptions:s}=await Promise.resolve().then(()=>$);return{getSubscriptions:s}},void 0);await r(!0),t({success:!0,subscription:a})}catch(o){console.error("Failed to subscribe to channel:",o),t({success:!1,error:"Failed to subscribe to channel"})}}async function Ho(e,t){try{const o=await l("pb_token");if(!o){t({success:!1,error:"No access token available"});return}const{getSubscriptions:n}=await C(async()=>{const{getSubscriptions:i}=await Promise.resolve().then(()=>$);return{getSubscriptions:i}},void 0),r=(await n(!1)).find(i=>i.iden===e),s=r?.channel?.iden,c=await k.fetch(`https://api.pushbullet.com/v2/subscriptions/${e}`,{method:"DELETE",headers:{"Access-Token":o,"Content-Type":"application/json"}});if(!c.ok){if(c.status===404){const{clearSubscriptionsCache:i}=await C(async()=>{const{clearSubscriptionsCache:w}=await Promise.resolve().then(()=>$);return{clearSubscriptionsCache:w}},void 0);await i(),await le(s,r),t({success:!0,message:"Already unsubscribed"});return}if(c.status===401){await u(h.TokenRevoked,{message:"Token revoked during channel unsubscription",code:c.status}),t({success:!1,error:"Token is invalid or revoked"});return}throw new Error(`Failed to unsubscribe: ${c.status} ${c.statusText}`)}s&&await Ro(s),await le(s,r),await n(!0),t({success:!0})}catch(o){console.error("Failed to unsubscribe from channel:",o),t({success:!1,error:"Failed to unsubscribe from channel"})}}async function Wo(e,t){try{const o=await k.fetch(`https://api.pushbullet.com/v2/channel-info?tag=${encodeURIComponent(e)}`,{method:"GET",headers:{"Content-Type":"application/json"}});if(!o.ok){if(o.status===404){t({success:!1,error:"Channel not found"});return}throw new Error(`Failed to get channel info: ${o.status} ${o.statusText}`)}const n=await o.json();t({success:!0,channelInfo:n})}catch(o){console.error("Failed to get channel info:",o),t({success:!1,error:"Failed to get channel information"})}}async function Ro(e){try{const t=await chrome.storage.local.get("pb_recent_pushes_state");if(!t.pb_recent_pushes_state)return;const o=t.pb_recent_pushes_state,n=o.pushes||[],a=n.filter(s=>s.channel_iden!==e),r={...o,pushes:a};await chrome.storage.local.set({pb_recent_pushes_state:r}),console.log(`Cleaned up ${n.length-a.length} pushes for channel ${e}`)}catch(t){console.error("Failed to cleanup channel pushes:",t)}}async function le(e,t){try{if(!e&&!t)return;const{ContextManager:o}=await C(async()=>{const{ContextManager:r}=await Promise.resolve().then(()=>St);return{ContextManager:r}},void 0),n=o.getInstance();e&&await n.removeChannelFromContext(e);const a=["pb_channel_subs","pb_owned_channels"];for(const r of a)try{const s=await chrome.storage.local.get(r);if(s[r]){if(r==="pb_channel_subs"&&s[r].subscriptions){const c=s[r].subscriptions.filter(i=>i.channel&&i.channel.iden!==e);await chrome.storage.local.set({[r]:{...s[r],subscriptions:c}})}if(r==="pb_owned_channels"&&s[r].channels){const c=s[r].channels.filter(i=>i.iden!==e);await chrome.storage.local.set({[r]:{...s[r],channels:c}})}}}catch(s){console.error(`Failed to cleanup ${r}:`,s)}console.log(`Cleaned up channel ${e} from local storage`)}catch(o){console.error("Failed to cleanup channel from storage:",o)}}async function Go(e){try{const t=await ge();e({success:!0,ownedChannels:t})}catch(t){console.error("Failed to get owned channels:",t),e({success:!1,error:t instanceof Error?t.message:"Failed to get owned channels"})}}async function jo(e){try{await V(),e({success:!0})}catch(t){console.error("Failed to refresh channel data:",t),e({success:!1,error:t instanceof Error?t.message:"Unknown error"})}}async function zo(e){try{const t=await ke();e({success:!0,posts:t})}catch(t){console.error("Failed to get subscription posts:",t),e({success:!1,error:t instanceof Error?t.message:"Unknown error"})}}async function qo(e){try{console.log("üí¨ [Background] Clearing SMS notifications from badge"),await _.clearSmsNotifications(),console.log("üí¨ [Background] SMS notifications cleared from badge"),e({ok:!0})}catch(t){console.error("Failed to clear SMS notifications:",t),e({ok:!1,error:"Failed to clear SMS notifications"})}}async function Vo(e){try{console.log("üßπ [Background] Starting complete data clear..."),await chrome.storage.local.clear(),console.log("üßπ [Background] All chrome.storage.local data cleared"),await chrome.storage.session.clear(),console.log("üßπ [Background] All chrome.storage.session data cleared");try{E.reset(),console.log("üßπ [Background] Token bucket reset")}catch(t){console.warn("üßπ [Background] Failed to reset token bucket:",t)}try{await R.clearState(),console.log("üßπ [Background] Rate limit manager reset")}catch(t){console.warn("üßπ [Background] Failed to reset rate limit manager:",t)}try{await y.clearAllNotifications(),console.log("üßπ [Background] Notification tracker reset")}catch(t){console.warn("üßπ [Background] Failed to reset notification tracker:",t)}try{await xe(),console.log("üßπ [Background] Operation queue cleared")}catch(t){console.warn("üßπ [Background] Failed to clear operation queue:",t)}console.log("üéâ [Background] All extension data cleared successfully"),e({success:!0,message:"All extension data has been cleared"})}catch(t){console.error("‚ùå [Background] Failed to clear all data:",t),e({success:!1,error:"Failed to clear all data",details:t instanceof Error?t.message:"Unknown error"})}}async function Ko(e){try{const t=await Jo();e({ok:!0,lastHeartbeat:t})}catch(t){console.error("WebSocket test failed:",t),e({ok:!1,error:"WebSocket test failed"})}}async function Yo(e){try{const t=await Zo();e({ok:!0,log:t})}catch(t){console.error("Failed to collect debug log:",t),e({ok:!1,error:"Failed to collect debug log"})}}async function Qo(e){try{const t=Date.now();console.log("ü™ü [Background] Popup opened, clearing all notifications");const o=await l(ie),n=!o||t-o>ro;console.log(`ü™ü [PopupTime] Last popup opened: ${o?new Date(F(o)).toISOString():"never"}, current: ${new Date(F(t)).toISOString()}, should sync SMS: ${n}`),await d(ie,t),await y.markAsSeen(),await _.clearPushNotifications(),n?(console.log("ü™ü [PopupTime] Triggering SMS sync (>1 hour since last popup open)"),H("popup_open")):console.log("ü™ü [PopupTime] Skipping SMS sync (<1 hour since last popup open)"),await _.refreshBadge(),console.log("ü™ü [Background] All notifications marked as seen, badge refreshed"),e({ok:!0})}catch(t){console.error("Failed to handle popup open:",t),e({ok:!1,error:"Failed to clear notifications"})}}async function Jo(){return new Date().toISOString()}async function Xo(e){try{const t=y.getState();e({ok:!0,state:t})}catch(t){console.error("Failed to get unified tracker state:",t),e({ok:!1,error:"Failed to get tracker state"})}}async function Zo(){const e=[];e.push("=== Pushbridge Debug Log ==="),e.push(`Generated: ${new Date().toISOString()}`),e.push("Extension Version: 1.0.0"),e.push("Chrome Version: Chrome Extension"),e.push("");try{const t=await chrome.storage.local.get(null);e.push("=== Storage Info ==="),e.push(`Token exists: ${!!t.pb_token}`),e.push(`Device IDEN: ${t.pb_device_iden||"Not set"}`),e.push(`Settings: ${JSON.stringify(t.pb_settings||{},null,2)}`),e.push("")}catch(t){e.push(`Failed to read storage: ${t}`)}try{const t=y.getState();e.push("=== Unified Tracker State ==="),e.push(`Last Seen: ${new Date(F(t.timestamps.lastSeenTimestamp)).toISOString()}`),e.push(`Last Updated: ${new Date(F(t.timestamps.lastUpdated)).toISOString()}`),e.push(`Cache Entries: ${Object.values(t.cache).reduce((o,n)=>o+n.length,0)}`),e.push("")}catch(t){e.push(`Failed to get tracker state: ${t}`)}return e.push("=== Recent Activity ==="),e.push("WebSocket status: Connected"),e.push(`Last push received: ${new Date().toISOString()}`),e.push("Queue status: Active"),e.join(`
`)}
