var w=(a=>(a.TokenRevoked="TOKEN_REVOKED",a.QuotaExceeded="QUOTA_EXCEEDED",a.WSMaxRetries="WS_MAX_RETRIES",a.UploadInterrupted="UPLOAD_INTERRUPTED",a.RateLimited="RATE_LIMITED",a.QuotaExhausted="QUOTA_EXHAUSTED",a.BackoffActive="BACKOFF_ACTIVE",a.QueueFull="QUEUE_FULL",a.FileTooLarge="FILE_TOO_LARGE",a.InvalidUpload="INVALID_UPLOAD",a.NetworkError="NETWORK_ERROR",a.Timeout="TIMEOUT",a.Unknown="UNKNOWN",a))(w||{});async function k(a,e){const t=Q(a,e);return e&&typeof e=="object"?console.error(`[Pushbridge Error] ${a}:`,JSON.stringify(e,null,2)):console.error(`[Pushbridge Error] ${a}:`,e),t.severity!=="info"&&await H(t),t.shouldRetry}function Q(a,e){const t=Date.now();switch(a){case"TOKEN_REVOKED":return{error:a,details:{...e,timestamp:t},shouldRetry:!1,severity:"error"};case"QUOTA_EXCEEDED":return{error:a,details:{...e,timestamp:t},shouldRetry:!1,severity:"warning"};case"WS_MAX_RETRIES":return{error:a,details:{...e,timestamp:t},shouldRetry:!1,severity:"error"};case"UPLOAD_INTERRUPTED":return{error:a,details:{...e,timestamp:t,retryable:!0},shouldRetry:!0,severity:"warning"};case"RATE_LIMITED":return{error:a,details:{...e,timestamp:t,retryable:!0},shouldRetry:!0,severity:"warning"};case"QUOTA_EXHAUSTED":return{error:a,details:{...e,timestamp:t,retryable:!0},shouldRetry:!0,severity:"warning"};case"BACKOFF_ACTIVE":return{error:a,details:{...e,timestamp:t,retryable:!0},shouldRetry:!0,severity:"warning"};case"QUEUE_FULL":return{error:a,details:{...e,timestamp:t,retryable:!0},shouldRetry:!0,severity:"warning"};case"FILE_TOO_LARGE":return{error:a,details:{...e,timestamp:t},shouldRetry:!1,severity:"warning"};case"INVALID_UPLOAD":return{error:a,details:{...e,timestamp:t},shouldRetry:!1,severity:"error"};case"NETWORK_ERROR":return{error:a,details:{...e,timestamp:t,retryable:!0},shouldRetry:!0,severity:"warning"};case"TIMEOUT":return{error:a,details:{...e,timestamp:t,retryable:!0},shouldRetry:!0,severity:"warning"};case"UNKNOWN":default:return{error:a,details:{...e,timestamp:t},shouldRetry:!1,severity:"error"}}}async function H(a){const e=K(a);try{await chrome.notifications.create({type:"basic",iconUrl:"icons/48.png",title:"Pushbridge Error",message:e})}catch(t){console.error("Failed to create notification:",t)}}function K(a){switch(a.error){case"TOKEN_REVOKED":return"Your Pushbullet token has been revoked. Please update your token in the extension settings.";case"QUOTA_EXCEEDED":return"Storage quota exceeded. Old data has been cleaned up automatically.";case"WS_MAX_RETRIES":return"Connection to Pushbullet failed after multiple attempts. Please check your internet connection.";case"UPLOAD_INTERRUPTED":return"File upload was interrupted. You can retry the upload.";case"RATE_LIMITED":return"Rate limit exceeded. Please wait a moment before retrying.";case"QUOTA_EXHAUSTED":return"API quota exhausted. Operations are being queued.";case"BACKOFF_ACTIVE":return"Rate limit backoff active. Please wait before retrying.";case"QUEUE_FULL":return"Operation queue is full. Please wait for processing to complete.";case"FILE_TOO_LARGE":return"File is too large. Maximum file size is 25MB.";case"INVALID_UPLOAD":return"Invalid upload request. Please try again with a different file.";case"NETWORK_ERROR":return"Network error during upload. Please check your connection and try again.";case"TIMEOUT":return"Upload timed out. Please try again.";case"UNKNOWN":default:return a.details?.message||"An unexpected error occurred. Please try again."}}async function l(a){return new Promise(e=>{chrome.storage.local.get(a,t=>{e(t[a])})})}async function r(a,e){return new Promise(t=>{chrome.storage.local.set({[a]:e},t)})}async function we(a){return new Promise(e=>{chrome.storage.local.remove(a,e)})}async function ke(){return new Promise(a=>{chrome.storage.local.getBytesInUse(null,a)})}class j{constructor(){this.rateState=null,this.backoffState={isActive:!1,backoffSeconds:15,expiresAt:0}}parseHeaders(e){const t=e.headers.get("X-Ratelimit-Limit"),s=e.headers.get("X-Ratelimit-Remaining"),o=e.headers.get("X-Ratelimit-Reset");console.log(`[RateLimit] Parsing headers - Status: ${e.status}, Limit: ${t}, Remaining: ${s}, Reset: ${o}`),t&&s&&o?(this.rateState={limit:parseInt(t,10),remaining:parseInt(s,10),reset:parseInt(o,10),lastUpdated:Date.now()},this.persistState(),console.log("[RateLimit] Rate limit headers parsed:",this.rateState)):console.log("[RateLimit] No rate limit headers found or incomplete headers")}getRateState(){return this.rateState}getRemaining(){return this.rateState?.remaining||0}getLimit(){return this.rateState?.limit||0}getResetTime(){return this.rateState?.reset||0}isBackoffActive(){if(console.log(`[RateLimit] Checking backoff state: isActive=${this.backoffState.isActive}, expiresAt=${this.backoffState.expiresAt}, now=${Date.now()}`),!this.backoffState.isActive)return!1;if(this.backoffState.expiresAt<=0)return console.error(`[RateLimit] INVALID STATE: backoff is active but expiresAt=${this.backoffState.expiresAt}. Deactivating.`),this.backoffState.isActive=!1,this.persistBackoffState(),!1;if(Date.now()>this.backoffState.expiresAt)return console.log("[RateLimit] Backoff expired, deactivating"),this.backoffState.isActive=!1,this.persistBackoffState(),!1;const e=this.backoffState.expiresAt-Date.now();return console.log(`[RateLimit] Backoff still active, ${Math.ceil(e/1e3)}s remaining`),!0}getBackoffState(){return{...this.backoffState}}getBackoffRemainingSeconds(){if(!this.backoffState.isActive)return 0;const e=Math.ceil((this.backoffState.expiresAt-Date.now())/1e3);return Math.max(0,e)}startBackoff(){console.log("[RateLimit] Starting backoff - Current state:",this.backoffState);const e=this.backoffState.backoffSeconds,t=Date.now()+e*1e3;this.backoffState.isActive=!0,this.backoffState.expiresAt=t,this.backoffState.backoffSeconds=Math.min(this.backoffState.backoffSeconds*2,300),this.backoffState.isActive&&this.backoffState.expiresAt<=0&&console.error("[RateLimit] CRITICAL BUG: About to persist invalid backoff state!",this.backoffState),this.persistBackoffState(),console.log(`[RateLimit] Backoff started: ${e}s active until ${new Date(t).toISOString()}, next backoff will be ${this.backoffState.backoffSeconds}s`)}resetBackoff(){this.backoffState.isActive&&(console.log("[RateLimit] Resetting backoff state due to successful request"),this.backoffState.isActive=!1,this.backoffState.backoffSeconds=15,this.backoffState.expiresAt=0,this.persistBackoffState(),console.log("[RateLimit] Backoff reset due to successful request after being active"))}async persistState(){try{await r("pb_rate_state",this.rateState)}catch(e){console.error("Failed to persist rate state:",e)}}async persistBackoffState(){try{await r("pb_backoff_state",this.backoffState)}catch(e){console.error("Failed to persist backoff state:",e)}}async loadState(){try{console.log("[RateLimit] Loading state from storage...");const[e,t]=await Promise.all([l("pb_rate_state"),l("pb_backoff_state")]);console.log("[RateLimit] Retrieved from storage:",{rateState:e,backoffState:t}),e?(this.rateState=e,console.log("[RateLimit] Rate state loaded from storage")):console.log("[RateLimit] No rate state found in storage"),t?(this.backoffState=t,console.log("[RateLimit] Backoff state loaded from storage:",t),t.isActive&&Date.now()>t.expiresAt&&(console.log("[RateLimit] Loaded backoff was expired, deactivating"),this.backoffState.isActive=!1,this.backoffState.expiresAt=0,this.persistBackoffState()),this.validateBackoffState()):console.log("[RateLimit] No backoff state found in storage, using defaults"),console.log("[RateLimit] Final state after loading:",{rateState:this.rateState,backoffState:this.backoffState})}catch(e){console.error("[RateLimit] Failed to load rate limit state:",e)}}async clearState(){this.rateState=null,this.backoffState={isActive:!1,backoffSeconds:15,expiresAt:0};try{await Promise.all([r("pb_rate_state",null),r("pb_backoff_state",null)])}catch(e){console.error("Failed to clear rate limit state:",e)}}getDebugInfo(){return{backoffState:{...this.backoffState},rateState:this.rateState?{...this.rateState}:null,isBackoffActive:this.isBackoffActive(),remainingSeconds:this.getBackoffRemainingSeconds(),currentTime:Date.now()}}validateBackoffState(){this.backoffState.isActive&&this.backoffState.expiresAt<=0&&(console.error("[RateLimit] FIXING INVALID STATE: backoff active but expiresAt <= 0"),this.backoffState.backoffSeconds>0?(this.backoffState.expiresAt=Date.now()+this.backoffState.backoffSeconds*1e3,console.log(`[RateLimit] Fixed by setting expiresAt to ${new Date(this.backoffState.expiresAt).toISOString()}`)):(this.backoffState.isActive=!1,this.backoffState.expiresAt=0,console.log("[RateLimit] Fixed by deactivating backoff")),this.persistBackoffState())}}const d=new j;class V{constructor(){this.bucket=60,this.lastRefill=0,this.maxBucketSize=120,this.lastConsumeLogTime=0,this.consumeLogThrottleInterval=5e3}initialize(){this.bucket===0&&this.lastRefill===0&&(this.bucket=60,this.lastRefill=Date.now(),console.log(`[TokenBucket] Initialized with ${this.bucket} tokens for startup`))}refillBucket(e){const t=Date.now(),s=Math.floor(t/6e4)*6e4;if(this.lastRefill===0){this.bucket=Math.min(e,this.maxBucketSize),this.lastRefill=s,console.log(`[TokenBucket] First refill: 0 → ${this.bucket} tokens (API remaining: ${e})`);return}if(this.lastRefill<s){const o=this.bucket;this.bucket=Math.min(e,this.maxBucketSize),this.lastRefill=s,console.log(`[TokenBucket] Refilled: ${o} → ${this.bucket} tokens (API remaining: ${e}, minute: ${new Date(s).toISOString()})`)}else{const o=s+6e4-t;this.bucket<=5&&console.log(`[TokenBucket] Refill not due yet - ${Math.ceil(o/1e3)}s remaining (bucket: ${this.bucket})`)}}canConsume(e=1){return this.bucket>=e}consume(e=1){if(!this.canConsume(e))return!1;this.bucket-=e;const t=Date.now();return t-this.lastConsumeLogTime>this.consumeLogThrottleInterval&&(console.log(`Consumed ${e} token(s), ${this.bucket} remaining`),this.lastConsumeLogTime=t),!0}getStatus(){return{bucket:this.bucket,remaining:0,lastRefill:this.lastRefill}}getBucketSize(){return this.bucket}getLastRefill(){return this.lastRefill}forceRefill(e){this.bucket=Math.min(e,this.maxBucketSize),this.lastRefill=Date.now(),console.log(`Token bucket force refilled: ${this.bucket} tokens`)}reset(){this.bucket=0,this.lastRefill=0,console.log("Token bucket reset")}getTimeUntilNextRefill(){const e=Date.now();return Math.floor(e/6e4)*6e4+6e4-e}needsRefill(){const e=Date.now(),t=Math.floor(e/6e4)*6e4;return this.lastRefill<t}getDetailedStatus(){const e=Date.now(),s=Math.floor(e/6e4)*6e4+6e4;return{bucket:this.bucket,maxBucketSize:this.maxBucketSize,lastRefill:this.lastRefill,lastRefillDate:new Date(this.lastRefill).toISOString(),nextRefillIn:Math.ceil((s-e)/1e3),canConsume1:this.canConsume(1)}}}const S=new V;class X{constructor(){this.queue=[],this.isProcessing=!1,this.processingInterval=null,this.maxRetryCount=3,this.processingDelay=5e3,this.lastNoTokensLogTime=0,this.lastBackoffLogTime=0,this.logThrottleInterval=5e3,this.hasBootstrapped=!1}enqueue(e){return new Promise((t,s)=>{const o={id:`${Date.now()}_${Math.random().toString(36).substr(2,9)}`,url:e.url,options:e.options,timestamp:Date.now(),retryCount:0,resolve:t,reject:s};this.queue.push(o),this.persistQueue(),console.log(`Operation queued: ${o.id} (${this.queue.length} pending)`),this.startProcessing()})}dequeue(){return this.queue.shift()||null}startProcessing(){if(this.isProcessing||this.processingInterval)return;this.isProcessing=!0,this.processingInterval=setInterval(()=>{this.processNextOperation()},this.processingDelay),console.log(`Queue processing started (interval: ${this.processingDelay}ms)`);const e=d.getBackoffState();console.log("[OperationQueue] Starting with backoff state:",e)}stopProcessing(){this.isProcessing=!1,this.processingInterval&&(clearInterval(this.processingInterval),this.processingInterval=null),console.log("Queue processing stopped")}async processNextOperation(){const e=Date.now();if(d.isBackoffActive()){if(e-this.lastBackoffLogTime>this.logThrottleInterval){const s=d.getBackoffRemainingSeconds();console.log(`Skipping queue processing - backoff active (${s}s remaining, ${this.queue.length} queued)`),this.lastBackoffLogTime=e}return}if(!S.canConsume(1)){const s=S.getDetailedStatus();if(!this.hasBootstrapped&&s.lastRefill===0&&this.queue.length>0)console.log("[OperationQueue] Bootstrap mode: allowing request despite no tokens (never been refilled)");else{if(e-this.lastNoTokensLogTime>this.logThrottleInterval){const i=S.getBucketSize(),n=d.getBackoffState();console.log(`Skipping queue processing - no tokens available (bucket: ${i}, ${this.queue.length} queued)`),console.log("[OperationQueue] Debug - backoff state when no tokens:",n),this.queue.length>0&&console.log("[OperationQueue] Queued operations:",this.queue.map(f=>({id:f.id,url:f.url,retryCount:f.retryCount}))),this.lastNoTokensLogTime=e}return}}const t=this.dequeue();if(!t){this.stopProcessing();return}try{const s=S.getBucketSize();console.log(`Processing queued operation: ${t.id} (bucket: ${s}, ${this.queue.length} remaining)`),S.consume(1);const o=await fetch(t.url,t.options);if(console.log(`[OperationQueue] Response status: ${o.status} for operation ${t.id}`),o.status===429)if(console.error(`[OperationQueue] Rate limited (429) for operation ${t.id}`),d.startBackoff(),this.stopProcessing(),t.retryCount<this.maxRetryCount){t.retryCount++,this.queue.unshift(t),console.log(`Re-queued operation ${t.id} (retry ${t.retryCount}/${this.maxRetryCount}) due to 429`),this.persistQueue();return}else{t.reject(new Error(`Operation failed after ${this.maxRetryCount} retries due to rate limiting`)),this.persistQueue();return}d.parseHeaders(o),S.refillBucket(d.getRemaining()),this.hasBootstrapped||(this.hasBootstrapped=!0,console.log("[OperationQueue] System bootstrapped after first successful API response")),d.resetBackoff(),t.resolve(o),console.log(`Queued operation completed: ${t.id}`)}catch(s){console.error(`Queued operation failed: ${t.id}`,s),t.reject(s)}this.persistQueue()}getQueueStatus(){return{pending:this.queue.length,processing:this.isProcessing}}getQueuedOperations(){return[...this.queue]}clearQueue(){this.queue.forEach(e=>{e.reject(new Error("Queue cleared"))}),this.queue=[],this.stopProcessing(),this.persistQueue(),console.log("Operation queue cleared")}async persistQueue(){try{const e=this.queue.map(t=>({id:t.id,url:t.url,options:t.options,timestamp:t.timestamp,retryCount:t.retryCount}));await r("pb_operation_queue",e)}catch(e){console.error("Failed to persist operation queue:",e)}}async loadQueue(){try{const e=await l("pb_operation_queue");e&&Array.isArray(e)&&(this.queue=e.map(t=>({...t,resolve:()=>{},reject:()=>{}})),console.log(`Loaded ${this.queue.length} operations from storage`),this.queue.length>0&&this.startProcessing())}catch(e){console.error("Failed to load operation queue:",e)}}async initialize(){await this.loadQueue(),console.log("Operation queue initialized")}cleanup(){this.stopProcessing(),this.persistQueue()}}const v=new X;class G{constructor(){this.isRateLimited=!1,this.notificationId=null}async showRateLimitNotification(e){if(!this.isRateLimited)try{await chrome.action.setBadgeText({text:"RL"}),await chrome.action.setBadgeBackgroundColor({color:"#FF6B6B"}),this.notificationId=`${Date.now()}_${Math.random().toString(36).substr(2,9)}`,await chrome.notifications.create(this.notificationId,{type:"basic",iconUrl:"icons/48.png",title:"Rate Limit Hit",message:`Retrying in ${e}s. Operations queued.`}),this.isRateLimited=!0,console.log(`Rate limit notification shown: ${e}s backoff`)}catch(t){console.error("Failed to show rate limit notification:",t)}}async clearRateLimitNotification(){if(this.isRateLimited)try{await chrome.action.setBadgeText({text:""});const e=`${Date.now()}_${Math.random().toString(36).substr(2,9)}`;if(await chrome.notifications.create(e,{type:"basic",iconUrl:"icons/48.png",title:"Rate Limit Cleared",message:"Operations resuming normally."}),this.notificationId){try{await chrome.notifications.clear(this.notificationId)}catch{}this.notificationId=null}this.isRateLimited=!1,console.log("Rate limit notification cleared")}catch(e){console.error("Failed to clear rate limit notification:",e)}}async showQueueStatus(e){if(e!==0)try{const t=`${Date.now()}_${Math.random().toString(36).substr(2,9)}`;await chrome.notifications.create(t,{type:"basic",iconUrl:"icons/48.png",title:"Operations Queued",message:`${e} operation(s) waiting to be processed.`}),console.log(`Queue status notification shown: ${e} pending`)}catch(t){console.error("Failed to show queue status notification:",t)}}async updateQueueBadge(e){try{e>0&&(await chrome.action.setBadgeText({text:`Q${e}`}),await chrome.action.setBadgeBackgroundColor({color:"#FFA500"}))}catch(t){console.error("Failed to update queue badge:",t)}}async showErrorNotification(e,t){try{const s=`${Date.now()}_${Math.random().toString(36).substr(2,9)}`;await chrome.notifications.create(s,{type:"basic",iconUrl:"icons/48.png",title:e,message:t}),console.log(`Error notification shown: ${e}`)}catch(s){console.error("Failed to show error notification:",s)}}async showSuccessNotification(e,t){try{const s=`${Date.now()}_${Math.random().toString(36).substr(2,9)}`;await chrome.notifications.create(s,{type:"basic",iconUrl:"icons/48.png",title:e,message:t}),console.log(`Success notification shown: ${e}`)}catch(s){console.error("Failed to show success notification:",s)}}isRateLimitNotificationActive(){return this.isRateLimited}getNotificationId(){return this.notificationId}async clearAllNotifications(){try{if(await chrome.action.setBadgeText({text:""}),this.notificationId){try{await chrome.notifications.clear(this.notificationId)}catch{}this.notificationId=null}this.isRateLimited=!1,console.log("All notifications cleared")}catch{console.error("Failed to clear all notifications")}}}const $=new G;class I extends Error{constructor(e){super(e),this.name="RateLimitError"}}class W{constructor(){this.lastNoTokensLogTime=0,this.logThrottleInterval=5e3}async initialize(){console.log("[HTTP] HTTP client initialized"),await d.loadState(),await v.initialize(),S.initialize()}async fetch(e,t={}){const s=Math.random().toString(36).substr(2,9),o=t.method||"GET";if(console.log(`🌐 [HTTP-${s}] ${o} ${e}`),console.log(`📋 [HTTP-${s}] Request options:`,{method:o,headers:t.headers,body:t.body?t.body.length>200?t.body.substring(0,200)+"...":t.body:void 0}),d.isBackoffActive()){const i=d.getBackoffRemainingSeconds();return console.log(`⏳ [HTTP-${s}] Backoff active, queuing operation. ${i}s remaining`),$.isRateLimitNotificationActive()||await $.showRateLimitNotification(i),v.enqueue({url:e,options:t})}if(!S.canConsume(1)){const i=Date.now();if(i-this.lastNoTokensLogTime>this.logThrottleInterval){const n=S.getBucketSize();console.log(`⏳ [HTTP-${s}] No tokens available, queuing operation (bucket: ${n})`),this.lastNoTokensLogTime=i}return v.enqueue({url:e,options:t})}try{console.log(`🚀 [HTTP-${s}] Making API request`),S.consume(1);const i=Date.now(),n=await fetch(e,t),f=Date.now()-i;if(console.log(`📡 [HTTP-${s}] Response received:`,{status:n.status,statusText:n.statusText,duration:`${f}ms`,contentType:n.headers.get("content-type"),contentLength:n.headers.get("content-length")}),d.parseHeaders(n),S.refillBucket(d.getRemaining()),d.resetBackoff(),$.isRateLimitNotificationActive()&&await $.clearRateLimitNotification(),n.status===429){console.error(`❌ [HTTP-${s}] Rate limited (429) - Starting backoff`);const u={"X-Ratelimit-Limit":n.headers.get("X-Ratelimit-Limit"),"X-Ratelimit-Remaining":n.headers.get("X-Ratelimit-Remaining"),"X-Ratelimit-Reset":n.headers.get("X-Ratelimit-Reset")};throw console.log(`[HTTP-${s}] Rate limit headers on 429:`,u),await this.handle429Error(),new I("Rate limited")}if(n.ok&&n.headers.get("content-type")?.includes("application/json"))try{const u=await n.text(),c=JSON.parse(u),p=new Response(u,{status:n.status,statusText:n.statusText,headers:n.headers});return console.log(`✅ [HTTP-${s}] Response data:`,{dataType:typeof c,isArray:Array.isArray(c),length:Array.isArray(c)?c.length:void 0,keys:Array.isArray(c)?void 0:Object.keys(c),sample:Array.isArray(c)&&c.length>0?c[0]:c}),p}catch(u){return console.warn(`⚠️ [HTTP-${s}] Could not parse JSON response:`,u),n}return console.log(`✅ [HTTP-${s}] Request completed successfully`),n}catch(i){throw console.error(`❌ [HTTP-${s}] HTTP request failed:`,{error:i,type:typeof i,isResponse:i instanceof Response,status:i instanceof Response?i.status:void 0,message:i instanceof Error?i.message:String(i)}),i instanceof Response&&i.status===429?(console.log(`[HTTP-${s}] 429 error caught in catch block (unexpected)`),await this.handle429Error(),new I("Rate limited")):i}}async handle429Error(){console.log("[HTTP] Handling 429 error - starting backoff sequence"),d.startBackoff();const e=d.getBackoffRemainingSeconds();console.log(`[HTTP] Backoff duration: ${e}s`),await $.showRateLimitNotification(e),v.stopProcessing(),console.log("[HTTP] Queue processing stopped due to 429 error")}getStatus(){return{rateState:d.getRateState(),backoffState:d.getBackoffState(),tokenBucket:S.getStatus(),queueStatus:v.getQueueStatus()}}cleanup(){v.cleanup()}}const _=new W,Y=1440*60*1e3;async function J(){try{const a=await l("pb_device_iden");if(a)return console.log("Using existing Chrome device:",a),a;const e=await Z();return await r("pb_device_iden",e),console.log("Created new Chrome device:",e),e}catch(a){throw console.error("Failed to ensure Chrome device:",a),await k(w.Unknown,{message:"Failed to register Chrome device",code:a instanceof Error?void 0:500}),a}}async function Z(){const a=await l("pb_token");if(!a)throw new Error("No token available for device creation");const e={nickname:"Chrome",type:"chrome",model:"Chrome Extension"},t=await _.fetch("https://api.pushbullet.com/v2/devices",{method:"POST",headers:{"Access-Token":a,"Content-Type":"application/json"},body:JSON.stringify(e)});if(!t.ok){if(t.status===401)throw await k(w.TokenRevoked,{message:"Token revoked during device creation",code:t.status}),new Error("Token is invalid or revoked");const o=await t.text();throw console.error("Device creation failed:",t.status,o),new Error(`Failed to create device: ${t.status} ${t.statusText}`)}return(await t.json()).iden}async function y(a=!1){try{if(!a){const s=await l("pb_device_cache");if(s&&Date.now()-s.lastFetched<Y)return console.log("Using cached device list"),s.devices}const e=await te(a),t={devices:e,lastFetched:Date.now(),cursor:await l("pb_devices_cursor"),hasMore:await l("pb_devices_has_more")||!1};return await r("pb_device_cache",t),console.log("Device list cached with",e.length,"devices"),e}catch(e){console.error("Failed to get devices:",e);const t=await l("pb_device_cache");if(t)return console.log("Returning expired cache due to fetch error"),t.devices;throw e}}async function ee(a=!1){const e=await y(a),t=await l("pb_device_iden");return e.filter(s=>s.active&&s.pushable!==!1&&s.iden!==t).sort((s,o)=>s.nickname.localeCompare(o.nickname))}async function te(a=!1){const e=await l("pb_token");if(!e)throw new Error("No token available");let t;a||(t=await l("pb_devices_cursor"));const s=new URLSearchParams;t&&s.append("cursor",t);const o=t?`https://api.pushbullet.com/v2/devices?${s}`:"https://api.pushbullet.com/v2/devices",i=await _.fetch(o,{method:"GET",headers:{"Access-Token":e,"Content-Type":"application/json"}});if(!i.ok)throw i.status===401?(await k(w.TokenRevoked,{message:"Token revoked while fetching devices",code:i.status}),new Error("Token is invalid or revoked")):new Error(`Failed to fetch devices: ${i.status} ${i.statusText}`);const n=await i.json();return n.cursor?(await r("pb_devices_cursor",n.cursor),await r("pb_devices_has_more",!0)):(await r("pb_devices_cursor",null),await r("pb_devices_has_more",!1)),n.devices||[]}async function se(){await r("pb_device_cache",null),await r("pb_devices_cursor",null),await r("pb_devices_has_more",null),console.log("Device cache and cursors cleared")}async function E(a=!1){console.log("[DeviceManager] Getting SMS-capable devices, forceRefresh:",a);const e=await y(a);console.log("[DeviceManager] Total devices:",e.length),console.log("[DeviceManager] All devices with SMS info:",e.map(s=>({iden:s.iden,nickname:s.nickname,has_sms:s.has_sms,active:s.active,created:s.created,type:s.type})));const t=e.filter(s=>s.has_sms===!0&&s.active).sort((s,o)=>s.nickname.localeCompare(o.nickname));return console.log("[DeviceManager] SMS-capable devices:",t.map(s=>({iden:s.iden,nickname:s.nickname,has_sms:s.has_sms,active:s.active}))),t}async function O(a=!1){try{console.log("[DeviceManager] Getting default SMS device, forceRefresh:",a);const e=await l("defaultSmsDevice");if(console.log("[DeviceManager] Stored default SMS device ID:",e),e&&!a){const s=await y();console.log("[DeviceManager] Found",s.length,"total devices"),console.log("[DeviceManager] All devices:",s.map(i=>({iden:i.iden,nickname:i.nickname,has_sms:i.has_sms,active:i.active,type:i.type})));const o=s.find(i=>i.iden===e&&i.has_sms===!0);if(o)return console.log("[DeviceManager] Using stored default SMS device:",o.nickname),o;{console.log("[DeviceManager] Stored device not found or not SMS-capable");const i=s.find(n=>n.iden===e);i?console.log("[DeviceManager] Device exists but criteria not met:",{iden:i.iden,nickname:i.nickname,has_sms:i.has_sms,active:i.active}):console.log("[DeviceManager] Device with ID",e,"not found in device list")}}console.log("[DeviceManager] Looking for SMS-capable devices...");const t=await E(a);if(console.log("[DeviceManager] Found",t.length,"SMS-capable devices"),t.length>0){const s=t[0];return await r("defaultSmsDevice",s.iden),console.log("[DeviceManager] Set default SMS device:",s.nickname),s}return console.log("[DeviceManager] No SMS-capable devices found"),await r("defaultSmsDevice",null),null}catch(e){return console.error("[DeviceManager] Failed to get default SMS device:",e),null}}async function ae(a=!1){try{return(await E(a)).length>0}catch(e){return console.error("Failed to check SMS devices:",e),!1}}async function L(a){try{console.log(`[DeviceManager] Handling default SMS device change to: ${a}`);const t=(await y()).find(s=>s.iden===a);if(!t){console.error(`[DeviceManager] New device ${a} not found`);return}if(!t.has_sms){console.error(`[DeviceManager] New device ${a} is not SMS-capable`);return}await pe(),await Se(a),await r("defaultSmsDevice",a),console.log(`[DeviceManager] Successfully switched to SMS device: ${t.nickname}`)}catch(e){console.error("[DeviceManager] Failed to handle default SMS device change:",e),await k(w.Unknown,{message:"Failed to handle default SMS device change",code:e instanceof Error?void 0:500})}}async function ie(a){try{console.log(`[DeviceManager] Setting default SMS device to: ${a}`);const t=(await y()).find(s=>s.iden===a);return t?t.has_sms?(await L(a),!0):(console.error(`[DeviceManager] Device ${a} is not SMS-capable`),!1):(console.error(`[DeviceManager] Device ${a} not found`),!1)}catch(e){return console.error("[DeviceManager] Failed to set default SMS device:",e),!1}}const Te=Object.freeze(Object.defineProperty({__proto__:null,clearDeviceCache:se,ensureChromeDevice:J,getDefaultSmsDevice:O,getDevices:y,getPushableDevices:ee,getSmsCapableDevices:E,handleDefaultSmsDeviceChange:L,hasSmsCapableDevices:ae,setDefaultSmsDevice:ie},Symbol.toStringTag,{value:"Module"}));class oe{constructor(){this.token=null}async initialize(){const e=await l("pb_token");if(this.token=e||null,!this.token)throw new Error("No Pushbullet token available")}async getSmsThreadsList(e){try{this.token||await this.initialize();const t=await this.getDeviceById(e);if(!t)throw new Error(`Device ${e} not found`);if(!t.has_sms)throw new Error(`Device ${e} is not SMS-capable`);const s=await _.fetch(`https://api.pushbullet.com/v2/permanents/${e}_threads`,{method:"GET",headers:{"Access-Token":this.token,"Content-Type":"application/json"}});if(!s.ok){if(s.status===401)throw await k(w.TokenRevoked,{message:"Token revoked during SMS threads fetch",code:s.status}),new Error("Token is invalid or revoked");if(s.status===404)throw new Error(`SMS threads not found for device ${e} - device may not support SMS or may be offline`);const o=await s.json().catch(()=>({}));throw new Error(`SMS threads fetch failed: ${s.status} ${s.statusText} - ${o.error?.message||"Unknown error"}`)}return await s.json()}catch(t){throw console.error(`Failed to get SMS threads for device ${e}:`,t),t}}async getSmsThreadMessages(e,t){try{console.log(`[SmsApiClient] Getting SMS thread messages for device: ${e}, thread: ${t}`),this.token||(console.log("[SmsApiClient] No token, initializing..."),await this.initialize());const s=await this.getDeviceById(e);if(!s)throw console.error(`[SmsApiClient] Device ${e} not found`),new Error(`Device ${e} not found`);if(!s.has_sms)throw console.error(`[SmsApiClient] Device ${e} is not SMS-capable`),new Error(`Device ${e} is not SMS-capable`);console.log(`[SmsApiClient] Making API request to: https://api.pushbullet.com/v2/permanents/${e}_thread_${t}`);const o=await _.fetch(`https://api.pushbullet.com/v2/permanents/${e}_thread_${t}`,{method:"GET",headers:{"Access-Token":this.token,"Content-Type":"application/json"}});if(console.log(`[SmsApiClient] Response status: ${o.status} ${o.statusText}`),!o.ok){if(console.error(`[SmsApiClient] API request failed: ${o.status} ${o.statusText}`),o.status===401)throw console.error("[SmsApiClient] Token revoked during SMS thread messages fetch"),await k(w.TokenRevoked,{message:"Token revoked during SMS thread messages fetch",code:o.status}),new Error("Token is invalid or revoked");if(o.status===404)throw console.error(`[SmsApiClient] SMS thread ${t} not found for device ${e}`),new Error(`SMS thread ${t} not found for device ${e}`);const n=await o.json().catch(()=>({}));throw console.error("[SmsApiClient] Error response data:",n),new Error(`SMS thread messages fetch failed: ${o.status} ${o.statusText} - ${n.error?.message||"Unknown error"}`)}const i=await o.json();return console.log("[SmsApiClient] Successfully retrieved SMS thread data:",{hasThread:!!i.thread,threadLength:i.thread?.length||0,threadKeys:i.thread?Object.keys(i.thread[0]||{}):[]}),i}catch(s){throw console.error(`Failed to get SMS thread messages for device ${e}, thread ${t}:`,s),s}}async getDeviceById(e){try{return(await y()).find(s=>s.iden===e)||null}catch(t){return console.error(`Failed to get device ${e}:`,t),null}}async getDeviceDisplayName(e){try{const t=await this.getDeviceById(e);if(t){if(t.nickname)return t.nickname;if(t.model&&t.manufacturer)return`${t.manufacturer} ${t.model}`;if(t.model)return t.model}return`Device ${e.slice(0,8)}`}catch(t){return console.error(`Failed to get device display name for ${e}:`,t),"Unknown Device"}}async verifyDeviceSmsCapability(e){try{const t=await this.getDeviceById(e);return t?t.has_sms===!0:!1}catch(t){return console.error(`Failed to verify SMS capability for device ${e}:`,t),!1}}async isDeviceOnline(e){try{const t=await this.getDeviceById(e);return t?t.active===!0:!1}catch(t){return console.error(`Failed to check online status for device ${e}:`,t),!1}}}const T=new oe;function N(a){const e=a*1e3;return Math.random()<.01&&console.log("⏰ [TimestampUtils] fromPushbulletTime conversion:",{inputSeconds:a,inputSecondsISO:new Date(a*1e3).toISOString(),outputMilliseconds:e,outputMillisecondsISO:new Date(e).toISOString(),conversionRatio:"1 second = 1000 milliseconds"}),e}function ne(){return Date.now()}const B=50,re=5e3,ce=1440*60*1e3,M={TIMESTAMPS:"unified_notification_timestamps",CACHE:"unified_notification_cache",COUNTS:"unified_notification_counts",VERSION:"unified_notification_tracker_version"};class b{constructor(){this.isInitialized=!1,this.timestamps={lastSeenTimestamp:0,lastProcessedPushTimestamp:0,lastProcessedMirrorTimestamp:0,lastProcessedSmsTimestamp:0,lastProcessedChannelTimestamp:0,lastUpdated:Date.now()},this.cache={pushIds:[],mirrorIds:[],smsIds:[],channelIds:[],lastCleanup:Date.now()},this.counts={pushes:0,mirrors:0,sms:0,channels:0,total:0}}static getInstance(){return b.instance||(b.instance=new b),b.instance}async initialize(){if(!this.isInitialized)try{console.log("🔄 [UnifiedTracker] Initializing notification tracker");const e=await l(M.TIMESTAMPS);e&&(this.timestamps={...this.timestamps,...e},console.log("🔄 [UnifiedTracker] Loaded timestamps:",this.timestamps));const t=await l(M.CACHE);t&&(this.cache={...this.cache,...t},console.log("🔄 [UnifiedTracker] Loaded cache with entries:",{pushIds:this.cache.pushIds.length,mirrorIds:this.cache.mirrorIds.length,smsIds:this.cache.smsIds.length,channelIds:this.cache.channelIds.length}));const s=await l(M.COUNTS);s&&(this.counts={...this.counts,...s},this.updateTotalCount(),console.log("🔄 [UnifiedTracker] Loaded counts:",this.counts)),await this.cleanupCache(),this.isInitialized=!0,console.log("✅ [UnifiedTracker] Initialization complete")}catch(e){console.error("❌ [UnifiedTracker] Failed to initialize:",e),this.isInitialized=!0}}async shouldShowNotification(e){await this.ensureInitialized();const t=typeof e.created=="string"?new Date(e.created).getTime():e.created,s=this.timestamps.lastSeenTimestamp*1e3,o=re,i=s-o;return console.log(`🔍 [UnifiedTracker] Evaluating notification: ${e.id}`,{notificationId:e.id,notificationType:e.type,createdTimestamp:t,createdISO:new Date(t).toISOString(),lastSeenTimestamp:this.timestamps.lastSeenTimestamp,lastSeenTimestampMs:s,lastSeenISO:new Date(s).toISOString(),bufferTimeMs:o,cutoffTimestampMs:i,cutoffISO:new Date(i).toISOString(),comparison:{createdVsLastSeen:t-s,createdVsCutoff:t-i,isNewerThanCutoff:t>i}}),t<=this.timestamps.lastSeenTimestamp*1e3-o?(console.log(`⏭️ [UnifiedTracker] REJECTED - Too old: ${e.id}`,{reason:"timestamp_too_old",createdMs:t,cutoffMs:i,differenceMs:t-i,createdISO:new Date(t).toISOString(),cutoffISO:new Date(i).toISOString()}),!1):this.isRecentlyProcessed(e.id,e.type)?(console.log(`⏭️ [UnifiedTracker] REJECTED - Recently processed: ${e.id}`,{reason:"recently_processed",notificationType:e.type,notificationId:e.id}),!1):(console.log(`✅ [UnifiedTracker] APPROVED - Will show notification: ${e.id}`,{notificationId:e.id,notificationType:e.type,createdISO:new Date(t).toISOString(),passedTimeCheck:!0,passedDuplicateCheck:!0}),!0)}async markAsProcessed(e,t,s){await this.ensureInitialized(),console.log(`📝 [UnifiedTracker] Marking as processed: ${t} (type: ${e}, timestamp: ${s})`);const o=`lastProcessed${e.charAt(0).toUpperCase()+e.slice(1)}Timestamp`;this.timestamps[o]<s&&(this.timestamps[o]=s),this.addToCache(e,t),this.timestamps.lastUpdated=Date.now(),await this.saveState()}async markAsSeen(e){await this.ensureInitialized();const t=(e||Date.now())/1e3;console.log(`👁️ [UnifiedTracker] Marking notifications as seen at: ${t}`),this.timestamps.lastSeenTimestamp=t,this.timestamps.lastUpdated=Date.now(),await this.saveState()}async incrementCount(e,t=1){await this.ensureInitialized();const s=this.getCountKey(e),o=this.counts[s],i=Math.max(0,o+t);this.counts[s]=i,this.updateTotalCount(),console.log(`📈 [UnifiedTracker] Incremented ${e} count:`,{type:e,amount:t,oldCount:o,newCount:i,total:this.counts.total}),await this.saveState()}async decrementCount(e,t=1){await this.ensureInitialized();const s=this.getCountKey(e),o=this.counts[s],i=Math.max(0,o-t);this.counts[s]=i,this.updateTotalCount(),console.log(`📉 [UnifiedTracker] Decremented ${e} count:`,{type:e,amount:t,oldCount:o,newCount:i,total:this.counts.total}),await this.saveState()}async setCount(e,t){await this.ensureInitialized();const s=this.getCountKey(e),o=this.counts[s],i=Math.max(0,t);this.counts[s]=i,this.updateTotalCount(),console.log(`🎯 [UnifiedTracker] Set ${e} count:`,{type:e,oldCount:o,newCount:i,total:this.counts.total}),await this.saveState()}async getUnreadCount(e){if(await this.ensureInitialized(),e){const t={push:"pushes",mirror:"mirrors",sms:"sms",channel:"channels"};return this.counts[t[e]]}return{...this.counts}}async clearAllNotifications(){await this.ensureInitialized(),console.log("🗑️ [UnifiedTracker] Clearing all notifications");const e=Date.now();this.timestamps={lastSeenTimestamp:e,lastProcessedPushTimestamp:e,lastProcessedMirrorTimestamp:e,lastProcessedSmsTimestamp:e,lastProcessedChannelTimestamp:e,lastUpdated:e},this.cache={pushIds:[],mirrorIds:[],smsIds:[],channelIds:[],lastCleanup:e},this.counts={pushes:0,mirrors:0,sms:0,channels:0,total:0},await this.saveState()}async clearNotifications(e){await this.ensureInitialized();const t=this.getCountKey(e),s=this.counts[t];this.counts[t]=0,this.updateTotalCount(),console.log(`🗑️ [UnifiedTracker] Cleared ${e} notifications:`,{type:e,oldCount:s,newCount:0,total:this.counts.total}),await this.saveState()}async validateState(){await this.ensureInitialized();const e=()=>{const s=Date.now();return this.timestamps.lastSeenTimestamp>=0&&this.timestamps.lastSeenTimestamp<=s&&this.timestamps.lastUpdated>=0&&this.timestamps.lastUpdated<=s&&this.counts.pushes>=0&&this.counts.mirrors>=0&&this.counts.sms>=0&&this.counts.channels>=0&&this.counts.total>=0},t=e();return t||(console.warn("⚠️ [UnifiedTracker] State validation failed, attempting recovery"),await this.recoverState(),e())}getState(){return{timestamps:{...this.timestamps},cache:{...this.cache},counts:{...this.counts}}}isRecentlyProcessed(e,t){const s=`${t}Ids`;return this.cache[s].includes(e)}addToCache(e,t){const s=`${e}Ids`,o=this.cache[s];o.unshift(t),o.length>B&&o.splice(B),this.cache[s]=o}getCountKey(e){return{push:"pushes",mirror:"mirrors",sms:"sms",channel:"channels"}[e]}updateTotalCount(){this.counts.total=this.counts.pushes+this.counts.mirrors+this.counts.sms+this.counts.channels}async cleanupCache(){const e=Date.now();e-this.cache.lastCleanup<ce||(console.log("🧹 [UnifiedTracker] Cleaning up cache"),this.cache.lastCleanup=e,await this.saveState())}async ensureInitialized(){this.isInitialized||await this.initialize()}async saveState(){try{await Promise.all([r(M.TIMESTAMPS,this.timestamps),r(M.CACHE,this.cache),r(M.COUNTS,this.counts)])}catch(e){console.error("❌ [UnifiedTracker] Failed to save state:",e)}}async recoverState(){console.log("🔄 [UnifiedTracker] Recovering from invalid state");const e=Date.now();this.timestamps={lastSeenTimestamp:e,lastProcessedPushTimestamp:e,lastProcessedMirrorTimestamp:e,lastProcessedSmsTimestamp:e,lastProcessedChannelTimestamp:e,lastUpdated:e},this.cache={pushIds:[],mirrorIds:[],smsIds:[],channelIds:[],lastCleanup:e},this.counts={pushes:0,mirrors:0,sms:0,channels:0,total:0},await this.saveState()}}const h=b.getInstance(),be=Object.freeze(Object.defineProperty({__proto__:null,UnifiedNotificationTracker:b,unifiedNotificationTracker:h},Symbol.toStringTag,{value:"Module"})),A=a=>`sms_data_${a}`,le=a=>`sms_last_sync_${a}`;async function ue(a){console.log(`🔄 [SimpleSMS] Starting complete SMS sync for device: ${a}`);try{if(await T.initialize(),!await T.isDeviceOnline(a))return console.warn(`⚠️ [SimpleSMS] Device ${a} is offline`),await R(a);console.log("📱 [SimpleSMS] Fetching SMS threads...");const t=await T.getSmsThreadsList(a),s=[];for(const i of t.threads){console.log(`📨 [SimpleSMS] Fetching messages for thread: ${i.id}`);try{const f=(await T.getSmsThreadMessages(a,i.id)).thread.map(m=>({id:m.id,pb_guid:m.guid||m.id,timestamp:N(m.timestamp),inbound:m.direction==="incoming",text:m.body,conversation_iden:i.id})),c=h.getState().timestamps.lastSeenTimestamp,p={id:i.id,name:P(i),messages:f.sort((m,g)=>m.timestamp-g.timestamp),lastMessageTime:f.length>0?Math.max(...f.map(m=>m.timestamp)):0,unreadCount:F(f,c),deviceIden:a,recipients:i.recipients};s.push(p),await fe(p)}catch(n){console.warn(`⚠️ [SimpleSMS] Failed to fetch messages for thread ${i.id}:`,n)}}const o={threads:s,lastSync:ne(),deviceIden:a};return await r(A(a),o),await r(le(a),o.lastSync),await U(),console.log(`✅ [SimpleSMS] Sync complete: ${s.length} threads, total messages: ${s.reduce((i,n)=>i+n.messages.length,0)}`),o}catch(e){return console.error(`❌ [SimpleSMS] Sync failed for device ${a}:`,e),await R(a)}}async function R(a){const e=await l(A(a));return e?(console.log(`💾 [SimpleSMS] Using cached data: ${e.threads.length} threads`),e):{threads:[],lastSync:0,deviceIden:a}}async function de(a,e){return(await R(a)).threads.find(s=>s.id===e)||null}async function he(a,e,t){try{const s=await R(a),o=s.threads.findIndex(i=>i.id===e);if(o!==-1){const i=s.threads[o];i.messages.push(t),i.messages.sort((n,f)=>n.timestamp-f.timestamp),i.lastMessageTime=Math.max(i.lastMessageTime,t.timestamp),await r(A(a),s),console.log(`📝 [SimpleSMS] Updated thread ${e} with sent message`)}else console.warn(`📝 [SimpleSMS] Thread ${e} not found for sent message update`)}catch(s){console.error("Failed to update thread with sent message:",s)}}async function ye(a,e){console.log(`🔄 [SimpleSMS] Reloading specific thread: ${e} for device: ${a}`);try{if(await T.initialize(),!await T.isDeviceOnline(a))return console.warn(`⚠️ [SimpleSMS] Device ${a} is offline`),null;console.log(`📨 [SimpleSMS] Fetching fresh messages for thread: ${e}`);const o=(await T.getSmsThreadMessages(a,e)).thread.map(g=>({id:g.id,pb_guid:g.guid||g.id,timestamp:N(g.timestamp),inbound:g.direction==="incoming",text:g.body,conversation_iden:e})),n=h.getState().timestamps.lastSeenTimestamp,u=(await T.getSmsThreadsList(a)).threads.find(g=>g.id===e);if(!u)return console.warn(`⚠️ [SimpleSMS] Thread ${e} not found in threads list`),null;const c={id:e,name:P(u),messages:o.sort((g,z)=>g.timestamp-z.timestamp),lastMessageTime:o.length>0?Math.max(...o.map(g=>g.timestamp)):0,unreadCount:F(o,n),deviceIden:a,recipients:u.recipients},p=await R(a),m=p.threads.findIndex(g=>g.id===e);return m>=0?p.threads[m]=c:p.threads.push(c),await r(A(a),p),console.log(`✅ [SimpleSMS] Successfully reloaded thread: ${e}`),c}catch(t){return console.error(`❌ [SimpleSMS] Failed to reload thread ${e}:`,t),null}}async function x(a){try{if(!a){const i=await O();if(!i)return 0;a=i.iden}const e=await R(a),t=e.threads.reduce((i,n)=>i+n.unreadCount,0),o=h.getState().timestamps.lastSeenTimestamp;return console.log("📊 [SMSCount] Total unread SMS count:",{deviceIden:a,totalThreads:e.threads.length,totalUnreadCount:t,lastSeenTimestamp:o,lastSeenISO:new Date(o*1e3).toISOString(),threadBreakdown:e.threads.map(i=>({name:i.name,id:i.id,unreadCount:i.unreadCount,lastMessageTime:i.lastMessageTime,lastMessageISO:new Date(i.lastMessageTime).toISOString()}))}),t}catch(e){return console.error("[SimpleSMS] Failed to get total unread count:",e),0}}async function U(){try{const a=await x();await h.setCount("sms",a),await q.refreshBadge(),console.log(`📱 [SimpleSMS] Updated badge with ${a} unread SMS`)}catch(a){console.error("[SimpleSMS] Failed to update SMS notification badge:",a)}}function P(a){return a.recipients&&a.recipients.length>0?a.recipients.map(t=>t.name||"Unknown").join(", ")||`Thread ${a.id}`:`Thread ${a.id}`}function F(a,e){const t=e?e*1e3:0,s=a.filter(o=>{const i=o.inbound,n=o.timestamp>t;return i&&n});return console.log("📊 [SMSCount] Calculated unread count:",{totalMessages:a.length,inboundMessages:a.filter(o=>o.inbound).length,unreadMessages:s.length,lastSeenTimestamp:e,cutoffTimestampMs:t,cutoffISO:t>0?new Date(t).toISOString():"never"}),s.length}async function fe(a){if(a.messages.length===0){console.log(`📱 [SMSNotif] No messages in thread: ${a.name}`);return}const e=a.messages[a.messages.length-1],s=h.getState().timestamps.lastSeenTimestamp;console.log("📱 [SMSNotif] Checking message for notification:",{threadName:a.name,messageId:e.id,isInbound:e.inbound,messageTimestamp:e.timestamp,messageTimestampISO:new Date(e.timestamp).toISOString(),lastSeenTimestamp:s,lastSeenTimestampISO:new Date(s*1e3).toISOString(),timestampComparison:{messageInMs:e.timestamp,lastSeenInMs:s*1e3,messageIsNewer:e.timestamp>s*1e3,timeDifferenceMs:e.timestamp-s*1e3}});const o=await h.shouldShowNotification({id:e.id,type:"sms",created:e.timestamp,metadata:{conversationId:a.id}});if(console.log("📱 [SMSNotif] Notification decision:",{threadName:a.name,messageId:e.id,shouldShow:o,isInbound:e.inbound,willCreateNotification:o&&e.inbound}),o&&e.inbound){console.log(`🔔 [SMSNotif] Creating Chrome notification for thread: ${a.name}, message: ${e.text.substring(0,50)}...`);const i=`sms_sync_${e.id}`;await chrome.notifications.create(i,{type:"basic",title:`SMS from ${a.name}`,message:e.text,iconUrl:"icons/48.png",requireInteraction:!1}),await U(),await h.markAsProcessed("sms",e.id,e.timestamp),console.log(`✅ [SMSNotif] Sync notification created: ${i} for message: ${e.id}`)}else e.inbound?console.log(`⏭️ [SMSNotif] Skipping notification (shouldShow=false): ${e.id}`):console.log(`⏭️ [SMSNotif] Skipping outbound message: ${e.id}`)}const C=new Map;async function ve(a,e,t){try{console.log("📝 [SMSBridge] Adding message to thread cache (OLD SYSTEM):",{conversationId:a,messageId:e.id,isInbound:e.inbound,timestamp:e.timestamp,timestampISO:new Date(e.timestamp).toISOString(),contactName:t||"unknown"});let s=C.get(a);if(s?(s.lastMessageTime=Math.max(s.lastMessageTime,e.timestamp),e.inbound&&s.unreadCount++,t&&t!==a&&(s.name=t),console.log(`📝 [SMSBridge] Updated existing thread: ${a}, unreadCount: ${s.unreadCount}`)):(s={id:a,name:t||a,messages:[],lastMessageTime:e.timestamp,unreadCount:e.inbound?1:0},C.set(a,s),console.log(`📝 [SMSBridge] Created new thread: ${a}`)),s.messages.some(n=>n.pb_guid===e.pb_guid)){console.log("⏭️ [SMSBridge] Skipping duplicate message:",e.pb_guid);return}const i=me(s.messages,e.timestamp);s.messages.splice(i,0,e),e.inbound&&(await h.markAsProcessed("sms",e.pb_guid,e.timestamp),console.log(`📝 [SMSBridge] Marked SMS as processed: ${e.pb_guid}`)),console.log(`✅ [SMSBridge] Added message to thread: ${a}, total messages: ${s.messages.length}`)}catch(s){console.error("Failed to add message to thread:",s),await k(w.Unknown,{message:"Failed to add message to thread",code:s instanceof Error?void 0:500})}}function me(a,e){let t=0,s=a.length;for(;t<s;){const o=Math.floor((t+s)/2);a[o].timestamp<e?t=o+1:s=o}return t}async function Me(a,e,t,s){try{if(!t.trim()&&(!s||s.length===0))throw new Error("Message cannot be empty");const o=await l("pb_token");if(!o)throw new Error("No token available");let i=await de(a,e);if(!i)throw console.log(`📱 [SMS] Conversation ${e} not found in cache`),new Error(`CONVERSATION_NOT_FOUND:${e}`);const n=[];if(i.recipients&&i.recipients.length>0)n.push(...i.recipients.map(m=>m.number));else throw new Error("No recipients found in conversation");if(n.length===0)throw new Error("No recipient phone numbers found");const f={data:{target_device_iden:a,addresses:n,message:t}};s&&s.length>0&&(f.data.file_type=s[0].content_type,f.file_url=s[0].url);const u=await _.fetch("https://api.pushbullet.com/v2/texts",{method:"POST",headers:{"Access-Token":o,"Content-Type":"application/json"},body:JSON.stringify(f)});if(!u.ok){if(u.status===401)throw await k(w.TokenRevoked,{message:"Token revoked during SMS send",code:u.status}),new Error("Token is invalid or revoked");const m=await u.json().catch(()=>({}));throw new Error(`SMS send failed: ${u.status} ${u.statusText} - ${m.error?.message||"Unknown error"}`)}const c=await u.json();console.log("SMS sent successfully via /v2/texts API:",c);const p={id:c.id||`${Date.now()}_${Math.random().toString(36).substr(2,9)}`,pb_guid:c.guid||`${Date.now()}_${Math.random().toString(36).substr(2,9)}`,timestamp:Date.now(),inbound:!1,text:t,conversation_iden:e};await he(a,e,p),console.log("SMS sent successfully to:",e)}catch(o){throw console.error("Failed to send SMS:",o),await k(w.Unknown,{message:"Failed to send SMS",code:o instanceof Error?void 0:500}),o}}async function ge(){try{const e=await x();if(e>0)return e}catch(e){console.warn("[SMSBridge] Simple SMS count failed, falling back to cache:",e)}let a=0;for(const e of C.values())a+=e.unreadCount;return a}async function Se(a){await ue(a)}async function pe(a){try{a||(C.clear(),console.log("[SMSBridge] Cleared entire SMS cache"))}catch(e){console.error("[SMSBridge] Failed to clear SMS cache:",e)}}class D{constructor(){this.badgeState={counts:{pushes:0,sms:0,total:0},lastUpdated:0},this.initializeBadge()}static getInstance(){return D.instance||(D.instance=new D),D.instance}async initializeBadge(){try{console.log("🏷️ [NotificationBadge] Initializing badge from storage"),await h.initialize();const e=await l("notification_badge_state");e?(this.badgeState=e,console.log("🏷️ [NotificationBadge] Loaded stored badge state:",this.badgeState)):console.log("🏷️ [NotificationBadge] No stored badge state found, using defaults"),await this.updateBadge()}catch(e){console.error("Failed to initialize notification badge:",e)}}async addPushNotifications(e){e>0?await h.incrementCount("push",e):e<0&&await h.decrementCount("push",Math.abs(e)),await this.updateBadge()}async updateSmsNotifications(){try{const e=await ge();await h.setCount("sms",e),await this.updateBadge()}catch(e){console.error("Failed to update SMS notifications:",e)}}async clearPushNotifications(){await h.clearNotifications("push"),await this.updateBadge()}async clearSmsNotifications(){await h.clearNotifications("sms"),await this.updateBadge()}async clearAllNotifications(){await h.clearAllNotifications(),await this.updateBadge()}async getNotificationCounts(){try{const e=await h.getUnreadCount();return this.badgeState.counts={pushes:e.pushes,sms:e.sms,total:e.total},{...this.badgeState.counts}}catch(e){return console.error("Failed to get notification counts from unified tracker:",e),{...this.badgeState.counts}}}async updateBadge(){try{const e=await h.getUnreadCount(),{total:t,pushes:s,sms:o}=e;if(this.badgeState.counts={pushes:s,sms:o,total:t},this.badgeState.lastUpdated=Date.now(),console.log("🏷️ [NotificationBadge] Updating badge:",{total:t,pushes:s,sms:o,badgeState:this.badgeState}),t===0)console.log("🏷️ [NotificationBadge] Clearing badge (no notifications)"),await chrome.action.setBadgeText({text:""});else if(t===1)console.log("🏷️ [NotificationBadge] Setting badge to red dot (single notification)"),await chrome.action.setBadgeText({text:"•"}),await chrome.action.setBadgeBackgroundColor({color:"#ef4444"});else{const i=t>99?"99+":t.toString();console.log("🏷️ [NotificationBadge] Setting badge to count:",i),await chrome.action.setBadgeText({text:i}),o>0&&s>0?(console.log("🏷️ [NotificationBadge] Setting badge color to purple (mixed notifications)"),await chrome.action.setBadgeBackgroundColor({color:"#8b5cf6"})):o>0?(console.log("🏷️ [NotificationBadge] Setting badge color to blue (SMS only)"),await chrome.action.setBadgeBackgroundColor({color:"#3b82f6"})):(console.log("🏷️ [NotificationBadge] Setting badge color to red (pushes only)"),await chrome.action.setBadgeBackgroundColor({color:"#ef4444"}))}await this.saveBadgeState()}catch(e){console.error("Failed to update notification badge:",e)}}async saveBadgeState(){try{console.log("🏷️ [NotificationBadge] Saving badge state to storage:",this.badgeState),await r("notification_badge_state",this.badgeState)}catch(e){console.error("Failed to save badge state:",e)}}async refreshBadge(){console.log("🏷️ [NotificationBadge] Refreshing badge state"),await this.updateSmsNotifications()}}const q=D.getInstance(),De=Object.freeze(Object.defineProperty({__proto__:null,notificationBadge:q},Symbol.toStringTag,{value:"Module"}));export{w as P,we as a,ve as b,ke as c,d,J as e,N as f,l as g,_ as h,ee as i,se as j,O as k,R as l,de as m,q as n,ye as o,Me as p,ue as q,k as r,r as s,S as t,h as u,ae as v,Te as w,be as x,De as y};
